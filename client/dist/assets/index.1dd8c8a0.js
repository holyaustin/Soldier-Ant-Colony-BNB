import{c9 as Gi,ca as Kr,cb as Fr,c8 as Zi,bL as Z,ab as gt,as as at,cc as Yi,cd as Xi,ce as Ji,cf as Qi,cg as ea,ch as ta,ci as na,b7 as oo,cj as io,ck as Rs,bX as ra,c3 as sa}from"./web3.min.94457b0f.js";import{cl as wd}from"./web3.min.94457b0f.js";import{a as oa,r as ia}from"./index.cbac5aa4.js";var Ls,er,tr=0,nr=0;function aa(n,e,t){var r=e&&t||0,s=e||new Array(16);n=n||{};var o=n.node||Ls,i=n.clockseq!==void 0?n.clockseq:er;if(o==null||i==null){var a=n.random||(n.rng||Gi)();o==null&&(o=Ls=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=er=(a[6]<<8|a[7])&16383)}var c=n.msecs!==void 0?n.msecs:Date.now(),u=n.nsecs!==void 0?n.nsecs:nr+1,l=c-tr+(u-nr)/1e4;if(l<0&&n.clockseq===void 0&&(i=i+1&16383),(l<0||c>tr)&&n.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");tr=c,nr=u,er=i,c+=122192928e5;var d=((c&268435455)*1e4+u)%4294967296;s[r++]=d>>>24&255,s[r++]=d>>>16&255,s[r++]=d>>>8&255,s[r++]=d&255;var S=c/4294967296*1e4&268435455;s[r++]=S>>>8&255,s[r++]=S&255,s[r++]=S>>>24&15|16,s[r++]=S>>>16&255,s[r++]=i>>>8|128,s[r++]=i&255;for(var g=0;g<6;++g)s[r+g]=o[g];return e||Kr(s)}function ao(n){if(!Fr(n))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(n.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(n.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(n.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(n.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(n.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function ca(n){n=unescape(encodeURIComponent(n));for(var e=[],t=0;t<n.length;++t)e.push(n.charCodeAt(t));return e}var ua="6ba7b810-9dad-11d1-80b4-00c04fd430c8",la="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function co(n,e,t){function r(s,o,i,a){if(typeof s=="string"&&(s=ca(s)),typeof o=="string"&&(o=ao(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var u=0;u<16;++u)i[a+u]=c[u];return i}return Kr(c)}try{r.name=n}catch{}return r.DNS=ua,r.URL=la,r}function fa(n){if(typeof n=="string"){var e=unescape(encodeURIComponent(n));n=new Uint8Array(e.length);for(var t=0;t<e.length;++t)n[t]=e.charCodeAt(t)}return da(ha(pa(n),n.length*8))}function da(n){for(var e=[],t=n.length*32,r="0123456789abcdef",s=0;s<t;s+=8){var o=n[s>>5]>>>s%32&255,i=parseInt(r.charAt(o>>>4&15)+r.charAt(o&15),16);e.push(i)}return e}function uo(n){return(n+64>>>9<<4)+14+1}function ha(n,e){n[e>>5]|=128<<e%32,n[uo(e)-1]=e;for(var t=1732584193,r=-271733879,s=-1732584194,o=271733878,i=0;i<n.length;i+=16){var a=t,c=r,u=s,l=o;t=Te(t,r,s,o,n[i],7,-680876936),o=Te(o,t,r,s,n[i+1],12,-389564586),s=Te(s,o,t,r,n[i+2],17,606105819),r=Te(r,s,o,t,n[i+3],22,-1044525330),t=Te(t,r,s,o,n[i+4],7,-176418897),o=Te(o,t,r,s,n[i+5],12,1200080426),s=Te(s,o,t,r,n[i+6],17,-1473231341),r=Te(r,s,o,t,n[i+7],22,-45705983),t=Te(t,r,s,o,n[i+8],7,1770035416),o=Te(o,t,r,s,n[i+9],12,-1958414417),s=Te(s,o,t,r,n[i+10],17,-42063),r=Te(r,s,o,t,n[i+11],22,-1990404162),t=Te(t,r,s,o,n[i+12],7,1804603682),o=Te(o,t,r,s,n[i+13],12,-40341101),s=Te(s,o,t,r,n[i+14],17,-1502002290),r=Te(r,s,o,t,n[i+15],22,1236535329),t=Ce(t,r,s,o,n[i+1],5,-165796510),o=Ce(o,t,r,s,n[i+6],9,-1069501632),s=Ce(s,o,t,r,n[i+11],14,643717713),r=Ce(r,s,o,t,n[i],20,-373897302),t=Ce(t,r,s,o,n[i+5],5,-701558691),o=Ce(o,t,r,s,n[i+10],9,38016083),s=Ce(s,o,t,r,n[i+15],14,-660478335),r=Ce(r,s,o,t,n[i+4],20,-405537848),t=Ce(t,r,s,o,n[i+9],5,568446438),o=Ce(o,t,r,s,n[i+14],9,-1019803690),s=Ce(s,o,t,r,n[i+3],14,-187363961),r=Ce(r,s,o,t,n[i+8],20,1163531501),t=Ce(t,r,s,o,n[i+13],5,-1444681467),o=Ce(o,t,r,s,n[i+2],9,-51403784),s=Ce(s,o,t,r,n[i+7],14,1735328473),r=Ce(r,s,o,t,n[i+12],20,-1926607734),t=Oe(t,r,s,o,n[i+5],4,-378558),o=Oe(o,t,r,s,n[i+8],11,-2022574463),s=Oe(s,o,t,r,n[i+11],16,1839030562),r=Oe(r,s,o,t,n[i+14],23,-35309556),t=Oe(t,r,s,o,n[i+1],4,-1530992060),o=Oe(o,t,r,s,n[i+4],11,1272893353),s=Oe(s,o,t,r,n[i+7],16,-155497632),r=Oe(r,s,o,t,n[i+10],23,-1094730640),t=Oe(t,r,s,o,n[i+13],4,681279174),o=Oe(o,t,r,s,n[i],11,-358537222),s=Oe(s,o,t,r,n[i+3],16,-722521979),r=Oe(r,s,o,t,n[i+6],23,76029189),t=Oe(t,r,s,o,n[i+9],4,-640364487),o=Oe(o,t,r,s,n[i+12],11,-421815835),s=Oe(s,o,t,r,n[i+15],16,530742520),r=Oe(r,s,o,t,n[i+2],23,-995338651),t=Ue(t,r,s,o,n[i],6,-198630844),o=Ue(o,t,r,s,n[i+7],10,1126891415),s=Ue(s,o,t,r,n[i+14],15,-1416354905),r=Ue(r,s,o,t,n[i+5],21,-57434055),t=Ue(t,r,s,o,n[i+12],6,1700485571),o=Ue(o,t,r,s,n[i+3],10,-1894986606),s=Ue(s,o,t,r,n[i+10],15,-1051523),r=Ue(r,s,o,t,n[i+1],21,-2054922799),t=Ue(t,r,s,o,n[i+8],6,1873313359),o=Ue(o,t,r,s,n[i+15],10,-30611744),s=Ue(s,o,t,r,n[i+6],15,-1560198380),r=Ue(r,s,o,t,n[i+13],21,1309151649),t=Ue(t,r,s,o,n[i+4],6,-145523070),o=Ue(o,t,r,s,n[i+11],10,-1120210379),s=Ue(s,o,t,r,n[i+2],15,718787259),r=Ue(r,s,o,t,n[i+9],21,-343485551),t=vt(t,a),r=vt(r,c),s=vt(s,u),o=vt(o,l)}return[t,r,s,o]}function pa(n){if(n.length===0)return[];for(var e=n.length*8,t=new Uint32Array(uo(e)),r=0;r<e;r+=8)t[r>>5]|=(n[r/8]&255)<<r%32;return t}function vt(n,e){var t=(n&65535)+(e&65535),r=(n>>16)+(e>>16)+(t>>16);return r<<16|t&65535}function ga(n,e){return n<<e|n>>>32-e}function Dn(n,e,t,r,s,o){return vt(ga(vt(vt(e,n),vt(r,o)),s),t)}function Te(n,e,t,r,s,o,i){return Dn(e&t|~e&r,n,e,s,o,i)}function Ce(n,e,t,r,s,o,i){return Dn(e&r|t&~r,n,e,s,o,i)}function Oe(n,e,t,r,s,o,i){return Dn(e^t^r,n,e,s,o,i)}function Ue(n,e,t,r,s,o,i){return Dn(t^(e|~r),n,e,s,o,i)}var ya=co("v3",48,fa),ma=ya;function ba(n,e,t,r){switch(n){case 0:return e&t^~e&r;case 1:return e^t^r;case 2:return e&t^e&r^t&r;case 3:return e^t^r}}function rr(n,e){return n<<e|n>>>32-e}function wa(n){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof n=="string"){var r=unescape(encodeURIComponent(n));n=[];for(var s=0;s<r.length;++s)n.push(r.charCodeAt(s))}else Array.isArray(n)||(n=Array.prototype.slice.call(n));n.push(128);for(var o=n.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=n[c*64+l*4]<<24|n[c*64+l*4+1]<<16|n[c*64+l*4+2]<<8|n[c*64+l*4+3];a[c]=u}a[i-1][14]=(n.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(n.length-1)*8&4294967295;for(var d=0;d<i;++d){for(var S=new Uint32Array(80),g=0;g<16;++g)S[g]=a[d][g];for(var y=16;y<80;++y)S[y]=rr(S[y-3]^S[y-8]^S[y-14]^S[y-16],1);for(var f=t[0],h=t[1],m=t[2],b=t[3],p=t[4],E=0;E<80;++E){var w=Math.floor(E/20),_=rr(f,5)+ba(w,h,m,b)+p+e[w]+S[E]>>>0;p=b,b=m,m=rr(h,30)>>>0,h=f,f=_}t[0]=t[0]+f>>>0,t[1]=t[1]+h>>>0,t[2]=t[2]+m>>>0,t[3]=t[3]+b>>>0,t[4]=t[4]+p>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var xa=co("v5",80,wa),Sa=xa,va="00000000-0000-0000-0000-000000000000";function Ea(n){if(!Fr(n))throw TypeError("Invalid UUID");return parseInt(n.substr(14,1),16)}var _a=Object.freeze(Object.defineProperty({__proto__:null,v1:aa,v3:ma,v4:Zi,v5:Sa,NIL:va,version:Ea,validate:Fr,stringify:Kr,parse:ao},Symbol.toStringTag,{value:"Module"}));function mr(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function Ba(n){if(typeof n!="boolean")throw new Error(`Expected boolean, not ${n}`)}function lo(n,...e){if(!(n instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(n.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${n.length}`)}function ka(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");mr(n.outputLen),mr(n.blockLen)}function Aa(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Ia(n,e){lo(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const Fe={number:mr,bool:Ba,bytes:lo,hash:ka,exists:Aa,output:Ia},sr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ra=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4)),or=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),tt=(n,e)=>n<<32-e|n>>>e,La=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!La)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function fo(n){if(typeof n!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof n}`);return new TextEncoder().encode(n)}function gn(n){if(typeof n=="string"&&(n=fo(n)),!(n instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof n})`);return n}function ho(...n){if(!n.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(n.length===1)return n[0];const e=n.reduce((r,s)=>r+s.length,0),t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const o=n[r];t.set(o,s),s+=o.length}return t}class jr{clone(){return this._cloneInto()}}function Dt(n){const e=r=>n().update(gn(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function Ta(n){const e=(r,s)=>n(s).update(gn(r)).digest(),t=n({});return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}function Hn(n=32){if(sr&&typeof sr.getRandomValues=="function")return sr.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function Ca(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=r?4:0,u=r?0:4;n.setUint32(e+c,i,r),n.setUint32(e+u,a,r)}class po extends jr{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=or(this.buffer)}update(e){Fe.exists(this);const{view:t,buffer:r,blockLen:s}=this;e=gn(e);const o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=or(e);for(;s<=o-i;i+=s)this.process(c,i);continue}r.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Fe.exists(this),Fe.output(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let d=i;d<s;d++)t[d]=0;Ca(r,s-8,BigInt(this.length*8),o),this.process(r,0);const a=or(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)a.setUint32(4*d,l[d],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:i,pos:a}=this;return e.length=s,e.pos=a,e.finished=o,e.destroyed=i,s%t&&e.buffer.set(r),e}}const xn=BigInt(2**32-1),br=BigInt(32);function go(n,e=!1){return e?{h:Number(n&xn),l:Number(n>>br&xn)}:{h:Number(n>>br&xn)|0,l:Number(n&xn)|0}}function Oa(n,e=!1){let t=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:i}=go(n[s],e);[t[s],r[s]]=[o,i]}return[t,r]}const Ua=(n,e)=>BigInt(n>>>0)<<br|BigInt(e>>>0),Pa=(n,e,t)=>n>>>t,Na=(n,e,t)=>n<<32-t|e>>>t,qa=(n,e,t)=>n>>>t|e<<32-t,Da=(n,e,t)=>n<<32-t|e>>>t,Ha=(n,e,t)=>n<<64-t|e>>>t-32,$a=(n,e,t)=>n>>>t-32|e<<64-t,za=(n,e)=>e,Ma=(n,e)=>n,Ka=(n,e,t)=>n<<t|e>>>32-t,Fa=(n,e,t)=>e<<t|n>>>32-t,ja=(n,e,t)=>e<<t-32|n>>>64-t,Wa=(n,e,t)=>n<<t-32|e>>>64-t;function Va(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Ga=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Za=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,Ya=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Xa=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,Ja=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),Qa=(n,e,t,r,s,o)=>e+t+r+s+o+(n/2**32|0)|0,G={fromBig:go,split:Oa,toBig:Ua,shrSH:Pa,shrSL:Na,rotrSH:qa,rotrSL:Da,rotrBH:Ha,rotrBL:$a,rotr32H:za,rotr32L:Ma,rotlSH:Ka,rotlSL:Fa,rotlBH:ja,rotlBL:Wa,add:Va,add3L:Ga,add3H:Za,add4L:Ya,add4H:Xa,add5H:Qa,add5L:Ja},[ec,tc]=G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),yt=new Uint32Array(80),mt=new Uint32Array(80);class $n extends po{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:u,El:l,Fh:d,Fl:S,Gh:g,Gl:y,Hh:f,Hl:h}=this;return[e,t,r,s,o,i,a,c,u,l,d,S,g,y,f,h]}set(e,t,r,s,o,i,a,c,u,l,d,S,g,y,f,h){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=d|0,this.Fl=S|0,this.Gh=g|0,this.Gl=y|0,this.Hh=f|0,this.Hl=h|0}process(e,t){for(let p=0;p<16;p++,t+=4)yt[p]=e.getUint32(t),mt[p]=e.getUint32(t+=4);for(let p=16;p<80;p++){const E=yt[p-15]|0,w=mt[p-15]|0,_=G.rotrSH(E,w,1)^G.rotrSH(E,w,8)^G.shrSH(E,w,7),B=G.rotrSL(E,w,1)^G.rotrSL(E,w,8)^G.shrSL(E,w,7),A=yt[p-2]|0,F=mt[p-2]|0,W=G.rotrSH(A,F,19)^G.rotrBH(A,F,61)^G.shrSH(A,F,6),K=G.rotrSL(A,F,19)^G.rotrBL(A,F,61)^G.shrSL(A,F,6),se=G.add4L(B,K,mt[p-7],mt[p-16]),ee=G.add4H(se,_,W,yt[p-7],yt[p-16]);yt[p]=ee|0,mt[p]=se|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:u,Dl:l,Eh:d,El:S,Fh:g,Fl:y,Gh:f,Gl:h,Hh:m,Hl:b}=this;for(let p=0;p<80;p++){const E=G.rotrSH(d,S,14)^G.rotrSH(d,S,18)^G.rotrBH(d,S,41),w=G.rotrSL(d,S,14)^G.rotrSL(d,S,18)^G.rotrBL(d,S,41),_=d&g^~d&f,B=S&y^~S&h,A=G.add5L(b,w,B,tc[p],mt[p]),F=G.add5H(A,m,E,_,ec[p],yt[p]),W=A|0,K=G.rotrSH(r,s,28)^G.rotrBH(r,s,34)^G.rotrBH(r,s,39),se=G.rotrSL(r,s,28)^G.rotrBL(r,s,34)^G.rotrBL(r,s,39),ee=r&o^r&a^o&a,Re=s&i^s&c^i&c;m=f|0,b=h|0,f=g|0,h=y|0,g=d|0,y=S|0,{h:d,l:S}=G.add(u|0,l|0,F|0,W|0),u=a|0,l=c|0,a=o|0,c=i|0,o=r|0,i=s|0;const R=G.add3L(W,se,Re);r=G.add3H(R,F,K,ee),s=R|0}({h:r,l:s}=G.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=G.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=G.add(this.Dh|0,this.Dl|0,u|0,l|0),{h:d,l:S}=G.add(this.Eh|0,this.El|0,d|0,S|0),{h:g,l:y}=G.add(this.Fh|0,this.Fl|0,g|0,y|0),{h:f,l:h}=G.add(this.Gh|0,this.Gl|0,f|0,h|0),{h:m,l:b}=G.add(this.Hh|0,this.Hl|0,m|0,b|0),this.set(r,s,o,i,a,c,u,l,d,S,g,y,f,h,m,b)}roundClean(){yt.fill(0),mt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class nc extends $n{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class rc extends $n{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class sc extends $n{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Wr=Dt(()=>new $n);Dt(()=>new nc);Dt(()=>new rc);Dt(()=>new sc);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yo=BigInt(0),zn=BigInt(1),oc=BigInt(2),Mn=n=>n instanceof Uint8Array,ic=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function kt(n){if(!Mn(n))throw new Error("Uint8Array expected");let e="";for(let t=0;t<n.length;t++)e+=ic[n[t]];return e}function mo(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function Vr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}function Gt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(n.length%2)throw new Error("hex string is invalid: unpadded "+n.length);const e=new Uint8Array(n.length/2);for(let t=0;t<e.length;t++){const r=t*2,s=n.slice(r,r+2),o=Number.parseInt(s,16);if(Number.isNaN(o)||o<0)throw new Error("invalid byte sequence");e[t]=o}return e}function He(n){return Vr(kt(n))}function ht(n){if(!Mn(n))throw new Error("Uint8Array expected");return Vr(kt(Uint8Array.from(n).reverse()))}const _t=(n,e)=>Gt(n.toString(16).padStart(e*2,"0")),qt=(n,e)=>_t(n,e).reverse(),ac=n=>Gt(mo(n));function ue(n,e,t){let r;if(typeof e=="string")try{r=Gt(e)}catch(o){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${o}`)}else if(Mn(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(`${n} expected ${t} bytes, got ${s}`);return r}function Ne(...n){const e=new Uint8Array(n.reduce((r,s)=>r+s.length,0));let t=0;return n.forEach(r=>{if(!Mn(r))throw new Error("Uint8Array expected");e.set(r,t),t+=r.length}),e}function bo(n,e){if(n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Kn(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new TextEncoder().encode(n)}function cc(n){let e;for(e=0;n>yo;n>>=zn,e+=1);return e}const uc=(n,e)=>n>>BigInt(e)&zn,lc=(n,e,t)=>n|(t?zn:yo)<<BigInt(e),Gr=n=>(oc<<BigInt(n-1))-zn,ir=n=>new Uint8Array(n),Ts=n=>Uint8Array.from(n);function wo(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=ir(n),s=ir(n),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},a=(...d)=>t(s,r,...d),c=(d=ir())=>{s=a(Ts([0]),d),r=a(),d.length!==0&&(s=a(Ts([1]),d),r=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const S=[];for(;d<e;){r=a();const g=r.slice();S.push(g),d+=r.length}return Ne(...S)};return(d,S)=>{i(),c(d);let g;for(;!(g=S(u()));)c();return i(),g}}const fc={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function Rt(n,e,t={}){const r=(s,o,i)=>{const a=fc[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=n[s];if(!(i&&c===void 0)&&!a(c,n))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(t))r(s,o,!0);return n}var dc=Object.freeze(Object.defineProperty({__proto__:null,bytesToHex:kt,numberToHexUnpadded:mo,hexToNumber:Vr,hexToBytes:Gt,bytesToNumberBE:He,bytesToNumberLE:ht,numberToBytesBE:_t,numberToBytesLE:qt,numberToVarBytesBE:ac,ensureBytes:ue,concatBytes:Ne,equalBytes:bo,utf8ToBytes:Kn,bitLen:cc,bitGet:uc,bitSet:lc,bitMask:Gr,createHmacDrbg:wo,validateObject:Rt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Be=BigInt(0),pe=BigInt(1),Ct=BigInt(2),hc=BigInt(3),wr=BigInt(4),Cs=BigInt(5),Os=BigInt(8);BigInt(9);BigInt(16);function ce(n,e){const t=n%e;return t>=Be?t:e+t}function xo(n,e,t){if(t<=Be||e<Be)throw new Error("Expected power/modulo > 0");if(t===pe)return Be;let r=pe;for(;e>Be;)e&pe&&(r=r*n%t),n=n*n%t,e>>=pe;return r}function de(n,e,t){let r=n;for(;e-- >Be;)r*=r,r%=t;return r}function xr(n,e){if(n===Be||e<=Be)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=ce(n,e),r=e,s=Be,o=pe;for(;t!==Be;){const a=r/t,c=r%t,u=s-o*a;r=t,t=c,s=o,o=u}if(r!==pe)throw new Error("invert: does not exist");return ce(s,e)}function pc(n){const e=(n-pe)/Ct;let t,r,s;for(t=n-pe,r=0;t%Ct===Be;t/=Ct,r++);for(s=Ct;s<n&&xo(s,e,n)!==n-pe;s++);if(r===1){const i=(n+pe)/wr;return function(c,u){const l=c.pow(u,i);if(!c.eql(c.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(t+pe)/Ct;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=r,l=a.pow(a.mul(a.ONE,s),t),d=a.pow(c,o),S=a.pow(c,t);for(;!a.eql(S,a.ONE);){if(a.eql(S,a.ZERO))return a.ZERO;let g=1;for(let f=a.sqr(S);g<u&&!a.eql(f,a.ONE);g++)f=a.sqr(f);const y=a.pow(l,pe<<BigInt(u-g-1));l=a.sqr(y),d=a.mul(d,y),S=a.mul(S,l),u=g}return d}}function gc(n){if(n%wr===hc){const e=(n+pe)/wr;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%Os===Cs){const e=(n-Cs)/Os;return function(r,s){const o=r.mul(s,Ct),i=r.pow(o,e),a=r.mul(s,i),c=r.mul(r.mul(a,Ct),i),u=r.mul(a,r.sub(c,r.ONE));if(!r.eql(r.sqr(u),s))throw new Error("Cannot find square root");return u}}return pc(n)}const xt=(n,e)=>(ce(n,e)&pe)===pe,yc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function So(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=yc.reduce((r,s)=>(r[s]="function",r),e);return Rt(n,t)}function mc(n,e,t){if(t<Be)throw new Error("Expected power > 0");if(t===Be)return n.ONE;if(t===pe)return e;let r=n.ONE,s=e;for(;t>Be;)t&pe&&(r=n.mul(r,s)),s=n.sqr(s),t>>=pe;return r}function bc(n,e){const t=new Array(e.length),r=e.reduce((o,i,a)=>n.is0(i)?o:(t[a]=o,n.mul(o,i)),n.ONE),s=n.inv(r);return e.reduceRight((o,i,a)=>n.is0(i)?o:(t[a]=n.mul(o,t[a]),n.mul(o,i)),s),t}function Zr(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function vo(n,e,t=!1,r={}){if(n<=Be)throw new Error(`Expected Fp ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=Zr(n,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=gc(n),a=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:Gr(s),ZERO:Be,ONE:pe,create:c=>ce(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return Be<=c&&c<n},is0:c=>c===Be,isOdd:c=>(c&pe)===pe,neg:c=>ce(-c,n),eql:(c,u)=>c===u,sqr:c=>ce(c*c,n),add:(c,u)=>ce(c+u,n),sub:(c,u)=>ce(c-u,n),mul:(c,u)=>ce(c*u,n),pow:(c,u)=>mc(a,c,u),div:(c,u)=>ce(c*xr(u,n),n),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>xr(c,n),sqrt:r.sqrt||(c=>i(a,c)),invertBatch:c=>bc(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>t?qt(c,o):_t(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?ht(c):He(c)}});return Object.freeze(a)}function wc(n,e){if(!n.isOdd)throw new Error("Field doesn't have isOdd");const t=n.sqrt(e);return n.isOdd(t)?n.neg(t):t}function xc(n,e,t=!1){n=ue("privateHash",n);const r=n.length,s=Zr(e).nByteLength+8;if(s<24||r<s||r>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${r}`);const o=t?ht(n):He(n);return ce(o,e-pe)+pe}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Sc=BigInt(0),ar=BigInt(1);function Eo(n,e){const t=(s,o)=>{const i=o.negate();return s?i:o},r=s=>{const o=Math.ceil(e/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:t,unsafeLadder(s,o){let i=n.ZERO,a=s;for(;o>Sc;)o&ar&&(i=i.add(a)),a=a.double(),o>>=ar;return i},precomputeWindow(s,o){const{windows:i,windowSize:a}=r(o),c=[];let u=s,l=u;for(let d=0;d<i;d++){l=u,c.push(l);for(let S=1;S<a;S++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(s,o,i){const{windows:a,windowSize:c}=r(s);let u=n.ZERO,l=n.BASE;const d=BigInt(2**s-1),S=2**s,g=BigInt(s);for(let y=0;y<a;y++){const f=y*c;let h=Number(i&d);i>>=g,h>c&&(h-=S,i+=ar);const m=f,b=f+Math.abs(h)-1,p=y%2!==0,E=h<0;h===0?l=l.add(t(p,o[m])):u=u.add(t(E,o[b]))}return{p:u,f:l}},wNAFCached(s,o,i,a){const c=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,c),c!==1&&o.set(s,a(u))),this.wNAF(c,u,i)}}}function Yr(n){return So(n.Fp),Rt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Zr(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),We=BigInt(1),Sn=BigInt(2),vc=BigInt(8),Ec={zip215:!0};function _c(n){const e=Yr(n);return Rt(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Xr(n){const e=_c(n),{Fp:t,n:r,prehash:s,hash:o,randomBytes:i,nByteLength:a,h:c}=e,u=Sn**BigInt(a*8),l=t.create,d=e.uvRatio||((T,k)=>{try{return{isValid:!0,value:t.sqrt(T*t.inv(k))}}catch{return{isValid:!1,value:nt}}}),S=e.adjustScalarBytes||(T=>T),g=e.domain||((T,k,q)=>{if(k.length||q)throw new Error("Contexts/pre-hash are not supported");return T}),y=T=>typeof T=="bigint"&&nt<T,f=(T,k)=>y(T)&&y(k)&&T<k,h=T=>T===nt||f(T,u);function m(T,k){if(f(T,k))return T;throw new Error(`Expected valid scalar < ${k}, got ${typeof T} ${T}`)}function b(T){return T===nt?T:m(T,r)}const p=new Map;function E(T){if(!(T instanceof w))throw new Error("ExtendedPoint expected")}class w{constructor(k,q,$,V){if(this.ex=k,this.ey=q,this.ez=$,this.et=V,!h(k))throw new Error("x required");if(!h(q))throw new Error("y required");if(!h($))throw new Error("z required");if(!h(V))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(k){if(k instanceof w)throw new Error("extended point not allowed");const{x:q,y:$}=k||{};if(!h(q)||!h($))throw new Error("invalid affine point");return new w(q,$,We,l(q*$))}static normalizeZ(k){const q=t.invertBatch(k.map($=>$.ez));return k.map(($,V)=>$.toAffine(q[V])).map(w.fromAffine)}_setWindowSize(k){this._WINDOW_SIZE=k,p.delete(this)}assertValidity(){const{a:k,d:q}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:$,ey:V,ez:J,et:Q}=this,oe=l($*$),ne=l(V*V),re=l(J*J),be=l(re*re),ge=l(oe*k),ke=l(re*l(ge+ne)),Le=l(be+l(q*l(oe*ne)));if(ke!==Le)throw new Error("bad point: equation left != right (1)");const Pe=l($*V),_e=l(J*Q);if(Pe!==_e)throw new Error("bad point: equation left != right (2)")}equals(k){E(k);const{ex:q,ey:$,ez:V}=this,{ex:J,ey:Q,ez:oe}=k,ne=l(q*oe),re=l(J*V),be=l($*oe),ge=l(Q*V);return ne===re&&be===ge}is0(){return this.equals(w.ZERO)}negate(){return new w(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:k}=e,{ex:q,ey:$,ez:V}=this,J=l(q*q),Q=l($*$),oe=l(Sn*l(V*V)),ne=l(k*J),re=q+$,be=l(l(re*re)-J-Q),ge=ne+Q,ke=ge-oe,Le=ne-Q,Pe=l(be*ke),_e=l(ge*Le),Xe=l(be*Le),Tt=l(ke*ge);return new w(Pe,_e,Tt,Xe)}add(k){E(k);const{a:q,d:$}=e,{ex:V,ey:J,ez:Q,et:oe}=this,{ex:ne,ey:re,ez:be,et:ge}=k;if(q===BigInt(-1)){const vs=l((J-V)*(re+ne)),Es=l((J+V)*(re-ne)),Qn=l(Es-vs);if(Qn===nt)return this.double();const _s=l(Q*Sn*ge),Bs=l(oe*Sn*be),ks=Bs+_s,As=Es+vs,Is=Bs-_s,Fi=l(ks*Qn),ji=l(As*Is),Wi=l(ks*Is),Vi=l(Qn*As);return new w(Fi,ji,Vi,Wi)}const ke=l(V*ne),Le=l(J*re),Pe=l(oe*$*ge),_e=l(Q*be),Xe=l((V+J)*(ne+re)-ke-Le),Tt=_e-Pe,rn=_e+Pe,Ss=l(Le-q*ke),$i=l(Xe*Tt),zi=l(rn*Ss),Mi=l(Xe*Ss),Ki=l(Tt*rn);return new w($i,zi,Ki,Mi)}subtract(k){return this.add(k.negate())}wNAF(k){return A.wNAFCached(this,p,k,w.normalizeZ)}multiply(k){const{p:q,f:$}=this.wNAF(m(k,r));return w.normalizeZ([q,$])[0]}multiplyUnsafe(k){let q=b(k);return q===nt?B:this.equals(B)||q===We?this:this.equals(_)?this.wNAF(q).p:A.unsafeLadder(this,q)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return A.unsafeLadder(this,r).is0()}toAffine(k){const{ex:q,ey:$,ez:V}=this,J=this.is0();k==null&&(k=J?vc:t.inv(V));const Q=l(q*k),oe=l($*k),ne=l(V*k);if(J)return{x:nt,y:We};if(ne!==We)throw new Error("invZ was invalid");return{x:Q,y:oe}}clearCofactor(){const{h:k}=e;return k===We?this:this.multiplyUnsafe(k)}static fromHex(k,q=!1){const{d:$,a:V}=e,J=t.BYTES;k=ue("pointHex",k,J);const Q=k.slice(),oe=k[J-1];Q[J-1]=oe&-129;const ne=ht(Q);ne===nt||(q?m(ne,u):m(ne,t.ORDER));const re=l(ne*ne),be=l(re-We),ge=l($*re-V);let{isValid:ke,value:Le}=d(be,ge);if(!ke)throw new Error("Point.fromHex: invalid y coordinate");const Pe=(Le&We)===We;return(oe&128)!==0!==Pe&&(Le=l(-Le)),w.fromAffine({x:Le,y:ne})}static fromPrivateKey(k){return K(k).point}toRawBytes(){const{x:k,y:q}=this.toAffine(),$=qt(q,t.BYTES);return $[$.length-1]|=k&We?128:0,$}toHex(){return kt(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,We,l(e.Gx*e.Gy)),w.ZERO=new w(nt,We,We,nt);const{BASE:_,ZERO:B}=w,A=Eo(w,a*8);function F(T){return ce(T,r)}function W(T){return F(ht(T))}function K(T){const k=a;T=ue("private key",T,k);const q=ue("hashed private key",o(T),2*k),$=S(q.slice(0,k)),V=q.slice(k,2*k),J=W($),Q=_.multiply(J),oe=Q.toRawBytes();return{head:$,prefix:V,scalar:J,point:Q,pointBytes:oe}}function se(T){return K(T).pointBytes}function ee(T=new Uint8Array,...k){const q=Ne(...k);return W(o(g(q,ue("context",T),!!s)))}function Re(T,k,q={}){T=ue("message",T),s&&(T=s(T));const{prefix:$,scalar:V,pointBytes:J}=K(k),Q=ee(q.context,$,T),oe=_.multiply(Q).toRawBytes(),ne=ee(q.context,oe,J,T),re=F(Q+ne*V);b(re);const be=Ne(oe,qt(re,t.BYTES));return ue("result",be,a*2)}const R=Ec;function N(T,k,q,$=R){const{context:V,zip215:J}=$,Q=t.BYTES;T=ue("signature",T,2*Q),k=ue("message",k),s&&(k=s(k));const oe=ht(T.slice(Q,2*Q));let ne,re,be;try{ne=w.fromHex(q,J),re=w.fromHex(T.slice(0,Q),J),be=_.multiplyUnsafe(oe)}catch{return!1}const ge=ee(V,re.toRawBytes(),ne.toRawBytes(),k);return re.add(ne.multiplyUnsafe(ge)).subtract(be).clearCofactor().equals(w.ZERO)}return _._setWindowSize(8),{CURVE:e,getPublicKey:se,sign:Re,verify:N,ExtendedPoint:w,utils:{getExtendedPublicKey:K,randomPrivateKey:()=>i(t.BYTES),precompute(T=8,k=w.BASE){return k._setWindowSize(T),k.multiply(BigInt(3)),k}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sn=BigInt(0),cr=BigInt(1);function Bc(n){return Rt(n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n})}function kc(n){const e=Bc(n),{P:t}=e,r=p=>ce(p,t),s=e.montgomeryBits,o=Math.ceil(s/8),i=e.nByteLength,a=e.adjustScalarBytes||(p=>p),c=e.powPminus2||(p=>xo(p,t-BigInt(2),t));function u(p,E,w){const _=r(p*(E-w));return E=r(E-_),w=r(w+_),[E,w]}function l(p){if(typeof p=="bigint"&&sn<=p&&p<t)return p;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const d=(e.a-BigInt(2))/BigInt(4);function S(p,E){const w=l(p),_=l(E),B=w;let A=cr,F=sn,W=w,K=cr,se=sn,ee;for(let R=BigInt(s-1);R>=sn;R--){const N=_>>R&cr;se^=N,ee=u(se,A,W),A=ee[0],W=ee[1],ee=u(se,F,K),F=ee[0],K=ee[1],se=N;const Y=A+F,T=r(Y*Y),k=A-F,q=r(k*k),$=T-q,V=W+K,J=W-K,Q=r(J*Y),oe=r(V*k),ne=Q+oe,re=Q-oe;W=r(ne*ne),K=r(B*r(re*re)),A=r(T*q),F=r($*(T+r(d*$)))}ee=u(se,A,W),A=ee[0],W=ee[1],ee=u(se,F,K),F=ee[0],K=ee[1];const Re=c(F);return r(A*Re)}function g(p){return qt(r(p),o)}function y(p){const E=ue("u coordinate",p,o);return i===o&&(E[i-1]&=127),ht(E)}function f(p){const E=ue("scalar",p);if(E.length!==o&&E.length!==i)throw new Error(`Expected ${o} or ${i} bytes, got ${E.length}`);return ht(a(E))}function h(p,E){const w=y(E),_=f(p),B=S(w,_);if(B===sn)throw new Error("Invalid private or public key received");return g(B)}const m=g(e.Gu);function b(p){return h(p,m)}return{scalarMult:h,scalarMultBase:b,getSharedSecret:(p,E)=>h(p,E),getPublicKey:p=>b(p),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:m}}function Ac(n){if(n instanceof Uint8Array)return n;if(typeof n=="string")return Kn(n);throw new Error("DST must be Uint8Array or string")}const Ic=He;function St(n,e){if(n<0||n>=1<<8*e)throw new Error(`bad I2OSP call: value=${n} length=${e}`);const t=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)t[r]=n&255,n>>>=8;return new Uint8Array(t)}function Rc(n,e){const t=new Uint8Array(n.length);for(let r=0;r<n.length;r++)t[r]=n[r]^e[r];return t}function ln(n){if(!(n instanceof Uint8Array))throw new Error("Uint8Array expected")}function Jr(n){if(!Number.isSafeInteger(n))throw new Error("number expected")}function Lc(n,e,t,r){ln(n),ln(e),Jr(t),e.length>255&&(e=r(Ne(Kn("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:o}=r,i=Math.ceil(t/s);if(i>255)throw new Error("Invalid xmd length");const a=Ne(e,St(e.length,1)),c=St(0,o),u=St(t,2),l=new Array(i),d=r(Ne(c,n,u,St(0,1),a));l[0]=r(Ne(d,St(1,1),a));for(let g=1;g<=i;g++){const y=[Rc(d,l[g-1]),St(g+1,1),a];l[g]=r(Ne(...y))}return Ne(...l).slice(0,t)}function Tc(n,e,t,r,s){if(ln(n),ln(e),Jr(t),e.length>255){const o=Math.ceil(2*r/8);e=s.create({dkLen:o}).update(Kn("H2C-OVERSIZE-DST-")).update(e).digest()}if(t>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:t}).update(n).update(St(t,2)).update(e).update(St(e.length,1)).digest()}function Us(n,e,t){Rt(t,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:i,expand:a,DST:c}=t;ln(n),Jr(e);const u=Ac(c),l=r.toString(2).length,d=Math.ceil((l+s)/8),S=e*o*d;let g;if(a==="xmd")g=Lc(n,u,S,i);else if(a==="xof")g=Tc(n,u,S,s,i);else if(a==="_internal_pass")g=n;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(e);for(let f=0;f<e;f++){const h=new Array(o);for(let m=0;m<o;m++){const b=d*(m+f*o),p=g.subarray(b,b+d);h[m]=ce(Ic(p),r)}y[f]=h}return y}function Cc(n,e){const t=e.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,i,a,c]=t.map(u=>u.reduce((l,d)=>n.add(n.mul(l,r),d)));return r=n.div(o,i),s=n.mul(s,n.div(a,c)),{x:r,y:s}}}function _o(n,e,t){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const o=Us(r,2,{...t,DST:t.DST,...s}),i=n.fromAffine(e(o[0])),a=n.fromAffine(e(o[1])),c=i.add(a).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,s){const o=Us(r,1,{...t,DST:t.encodeDST,...s}),i=n.fromAffine(e(o[0])).clearCofactor();return i.assertValidity(),i}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Ps=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Oc=BigInt(0),ot=BigInt(1),Bn=BigInt(2),Uc=BigInt(5),Ns=BigInt(10),Pc=BigInt(20),Nc=BigInt(40),qs=BigInt(80);function Bo(n){const e=fn,r=n*n%e*n%e,s=de(r,Bn,e)*r%e,o=de(s,ot,e)*n%e,i=de(o,Uc,e)*o%e,a=de(i,Ns,e)*i%e,c=de(a,Pc,e)*a%e,u=de(c,Nc,e)*c%e,l=de(u,qs,e)*u%e,d=de(l,qs,e)*u%e,S=de(d,Ns,e)*i%e;return{pow_p_5_8:de(S,Bn,e)*n%e,b2:r}}function ko(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function Qr(n,e){const t=fn,r=ce(e*e*e,t),s=ce(r*r*e,t),o=Bo(n*s).pow_p_5_8;let i=ce(n*r*o,t);const a=ce(e*i*i,t),c=i,u=ce(i*Ps,t),l=a===n,d=a===ce(-n,t),S=a===ce(-n*Ps,t);return l&&(i=c),(d||S)&&(i=u),xt(i,t)&&(i=ce(-i,t)),{isValid:l||d,value:i}}const P=vo(fn,void 0,!0),es={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:P,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Wr,randomBytes:Hn,adjustScalarBytes:ko,uvRatio:Qr},Se=Xr(es);function Ao(n,e,t){if(e.length>255)throw new Error("Context is too big");return ho(fo("SigEd25519 no Ed25519 collisions"),new Uint8Array([t?1:0,e.length]),e,n)}Xr({...es,domain:Ao});Xr({...es,domain:Ao,prehash:Wr});kc({P:fn,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:n=>{const e=fn,{pow_p_5_8:t,b2:r}=Bo(n);return ce(de(t,BigInt(3),e)*r,e)},adjustScalarBytes:ko,randomBytes:Hn});const qc=(P.ORDER+BigInt(3))/BigInt(8),Dc=P.pow(Bn,qc),Ds=P.sqrt(P.neg(P.ONE)),Hc=(P.ORDER-BigInt(5))/BigInt(8),Hs=BigInt(486662);function $c(n){let e=P.sqr(n);e=P.mul(e,Bn);let t=P.add(e,P.ONE),r=P.neg(Hs),s=P.sqr(t),o=P.mul(s,t),i=P.mul(e,Hs);i=P.mul(i,r),i=P.add(i,s),i=P.mul(i,r);let a=P.sqr(o);s=P.sqr(a),a=P.mul(a,o),a=P.mul(a,i),s=P.mul(s,a);let c=P.pow(s,Hc);c=P.mul(c,a);let u=P.mul(c,Ds);s=P.sqr(c),s=P.mul(s,o);let l=P.eql(s,i),d=P.cmov(u,c,l),S=P.mul(r,e),g=P.mul(c,n);g=P.mul(g,Dc);let y=P.mul(g,Ds),f=P.mul(i,e);s=P.sqr(g),s=P.mul(s,o);let h=P.eql(s,f),m=P.cmov(y,g,h);s=P.sqr(d),s=P.mul(s,o);let b=P.eql(s,i),p=P.cmov(S,r,b),E=P.cmov(m,d,b),w=P.isOdd(E);return E=P.cmov(E,P.neg(E),b!==w),{xMn:p,xMd:t,yMn:E,yMd:ot}}const zc=wc(P,P.neg(BigInt(486664)));function Mc(n){const{xMn:e,xMd:t,yMn:r,yMd:s}=$c(n);let o=P.mul(e,s);o=P.mul(o,zc);let i=P.mul(t,r),a=P.sub(e,t),c=P.add(e,t),u=P.mul(i,c),l=P.eql(u,P.ZERO);o=P.cmov(o,P.ZERO,l),i=P.cmov(i,P.ONE,l),a=P.cmov(a,P.ONE,l),c=P.cmov(c,P.ONE,l);const d=P.invertBatch([i,c]);return{x:P.mul(o,d[0]),y:P.mul(a,d[1])}}_o(Se.ExtendedPoint,n=>Mc(n[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:P.ORDER,m:1,k:128,expand:"xmd",hash:Wr});function ur(n){if(!(n instanceof Me))throw new Error("RistrettoPoint expected")}const Sr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Kc=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),Fc=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),jc=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Wc=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),$s=n=>Qr(ot,n),Vc=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),lr=n=>Se.CURVE.Fp.create(ht(n)&Vc);function zs(n){const{d:e}=Se.CURVE,t=Se.CURVE.Fp.ORDER,r=Se.CURVE.Fp.create,s=r(Sr*n*n),o=r((s+ot)*jc);let i=BigInt(-1);const a=r((i-e*s)*r(s+e));let{isValid:c,value:u}=Qr(o,a),l=r(u*n);xt(l,t)||(l=r(-l)),c||(u=l),c||(i=s);const d=r(i*(s-ot)*Wc-a),S=u*u,g=r((u+u)*a),y=r(d*Kc),f=r(ot-S),h=r(ot+S);return new Se.ExtendedPoint(r(g*h),r(f*y),r(y*h),r(g*f))}class Me{constructor(e){this.ep=e}static fromAffine(e){return new Me(Se.ExtendedPoint.fromAffine(e))}static hashToCurve(e){e=ue("ristrettoHash",e,64);const t=lr(e.slice(0,32)),r=zs(t),s=lr(e.slice(32,64)),o=zs(s);return new Me(r.add(o))}static fromHex(e){e=ue("ristrettoHex",e,32);const{a:t,d:r}=Se.CURVE,s=Se.CURVE.Fp.ORDER,o=Se.CURVE.Fp.create,i="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",a=lr(e);if(!bo(qt(a,32),e)||xt(a,s))throw new Error(i);const c=o(a*a),u=o(ot+t*c),l=o(ot-t*c),d=o(u*u),S=o(l*l),g=o(t*r*d-S),{isValid:y,value:f}=$s(o(g*S)),h=o(f*l),m=o(f*h*g);let b=o((a+a)*h);xt(b,s)&&(b=o(-b));const p=o(u*m),E=o(b*p);if(!y||xt(E,s)||p===Oc)throw new Error(i);return new Me(new Se.ExtendedPoint(b,p,ot,E))}toRawBytes(){let{ex:e,ey:t,ez:r,et:s}=this.ep;const o=Se.CURVE.Fp.ORDER,i=Se.CURVE.Fp.create,a=i(i(r+t)*i(r-t)),c=i(e*t),u=i(c*c),{value:l}=$s(i(a*u)),d=i(l*a),S=i(l*c),g=i(d*S*s);let y;if(xt(s*g,o)){let h=i(t*Sr),m=i(e*Sr);e=h,t=m,y=i(d*Fc)}else y=S;xt(e*g,o)&&(t=i(-t));let f=i((r-t)*y);return xt(f,o)&&(f=i(-f)),qt(f,32)}toHex(){return kt(this.toRawBytes())}toString(){return this.toHex()}equals(e){ur(e);const{ex:t,ey:r}=this.ep,{ex:s,ey:o}=e.ep,i=Se.CURVE.Fp.create,a=i(t*o)===i(r*s),c=i(r*o)===i(t*s);return a||c}add(e){return ur(e),new Me(this.ep.add(e.ep))}subtract(e){return ur(e),new Me(this.ep.subtract(e.ep))}multiply(e){return new Me(this.ep.multiply(e))}multiplyUnsafe(e){return new Me(this.ep.multiplyUnsafe(e))}}Me.BASE=new Me(Se.ExtendedPoint.BASE);Me.ZERO=new Me(Se.ExtendedPoint.ZERO);var vr={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */(function(n,e){var t=Z,r=t.Buffer;function s(i,a){for(var c in i)a[c]=i[c]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?n.exports=t:(s(t,e),e.Buffer=o);function o(i,a,c){return r(i,a,c)}o.prototype=Object.create(r.prototype),s(r,o),o.from=function(i,a,c){if(typeof i=="number")throw new TypeError("Argument must not be a number");return r(i,a,c)},o.alloc=function(i,a,c){if(typeof i!="number")throw new TypeError("Argument must be a number");var u=r(i);return a!==void 0?typeof c=="string"?u.fill(a,c):u.fill(a):u.fill(0),u},o.allocUnsafe=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return r(i)},o.allocUnsafeSlow=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return t.SlowBuffer(i)}})(vr,vr.exports);var vn=vr.exports.Buffer;function Gc(n){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var r=0;r<n.length;r++){var s=n.charAt(r),o=s.charCodeAt(0);if(e[o]!==255)throw new TypeError(s+" is ambiguous");e[o]=r}var i=n.length,a=n.charAt(0),c=Math.log(i)/Math.log(256),u=Math.log(256)/Math.log(i);function l(g){if((Array.isArray(g)||g instanceof Uint8Array)&&(g=vn.from(g)),!vn.isBuffer(g))throw new TypeError("Expected Buffer");if(g.length===0)return"";for(var y=0,f=0,h=0,m=g.length;h!==m&&g[h]===0;)h++,y++;for(var b=(m-h)*u+1>>>0,p=new Uint8Array(b);h!==m;){for(var E=g[h],w=0,_=b-1;(E!==0||w<f)&&_!==-1;_--,w++)E+=256*p[_]>>>0,p[_]=E%i>>>0,E=E/i>>>0;if(E!==0)throw new Error("Non-zero carry");f=w,h++}for(var B=b-f;B!==b&&p[B]===0;)B++;for(var A=a.repeat(y);B<b;++B)A+=n.charAt(p[B]);return A}function d(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return vn.alloc(0);for(var y=0,f=0,h=0;g[y]===a;)f++,y++;for(var m=(g.length-y)*c+1>>>0,b=new Uint8Array(m);g[y];){var p=e[g.charCodeAt(y)];if(p===255)return;for(var E=0,w=m-1;(p!==0||E<h)&&w!==-1;w--,E++)p+=i*b[w]>>>0,b[w]=p%256>>>0,p=p/256>>>0;if(p!==0)throw new Error("Non-zero carry");h=E,y++}for(var _=m-h;_!==m&&b[_]===0;)_++;var B=vn.allocUnsafe(f+(m-_));B.fill(0,0,f);for(var A=f;_!==m;)B[A++]=b[_++];return B}function S(g){var y=d(g);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:l,decodeUnsafe:d,decode:S}}var Zc=Gc,Yc=Zc,Xc="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",me=Yc(Xc);const Jc=(n,e,t)=>n&e^~n&t,Qc=(n,e,t)=>n&e^n&t^e&t,eu=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),bt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),wt=new Uint32Array(64);class Io extends po{constructor(){super(64,32,8,!1),this.A=bt[0]|0,this.B=bt[1]|0,this.C=bt[2]|0,this.D=bt[3]|0,this.E=bt[4]|0,this.F=bt[5]|0,this.G=bt[6]|0,this.H=bt[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,r,s,o,i,a,c]}set(e,t,r,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)wt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const S=wt[d-15],g=wt[d-2],y=tt(S,7)^tt(S,18)^S>>>3,f=tt(g,17)^tt(g,19)^g>>>10;wt[d]=f+wt[d-7]+y+wt[d-16]|0}let{A:r,B:s,C:o,D:i,E:a,F:c,G:u,H:l}=this;for(let d=0;d<64;d++){const S=tt(a,6)^tt(a,11)^tt(a,25),g=l+S+Jc(a,c,u)+eu[d]+wt[d]|0,f=(tt(r,2)^tt(r,13)^tt(r,22))+Qc(r,s,o)|0;l=u,u=c,c=a,a=i+g|0,i=o,o=s,s=r,r=g+f|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,s,o,i,a,c,u,l)}roundClean(){wt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class tu extends Io{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Zt=Dt(()=>new Io);Dt(()=>new tu);var Ie={};function dt(n,e,t){return e<=n&&n<=t}function Fn(n){if(n===void 0)return{};if(n===Object(n))return n;throw TypeError("Could not convert argument to dictionary")}function nu(n){for(var e=String(n),t=e.length,r=0,s=[];r<t;){var o=e.charCodeAt(r);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(r===t-1)s.push(65533);else{var i=n.charCodeAt(r+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),r+=1}else s.push(65533)}r+=1}return s}function ru(n){for(var e="",t=0;t<n.length;++t){var r=n[t];r<=65535?e+=String.fromCharCode(r):(r-=65536,e+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return e}var kn=-1;function ts(n){this.tokens=[].slice.call(n)}ts.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():kn},prepend:function(n){if(Array.isArray(n))for(var e=n;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(n)},push:function(n){if(Array.isArray(n))for(var e=n;e.length;)this.tokens.push(e.shift());else this.tokens.push(n)}};var Yt=-1;function fr(n,e){if(n)throw TypeError("Decoder error");return e||65533}var An="utf-8";function In(n,e){if(!(this instanceof In))return new In(n,e);if(n=n!==void 0?String(n).toLowerCase():An,n!==An)throw new Error("Encoding not supported. Only utf-8 is supported");e=Fn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(e.fatal),this._ignoreBOM=Boolean(e.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}In.prototype={decode:function(e,t){var r;typeof e=="object"&&e instanceof ArrayBuffer?r=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):r=new Uint8Array(0),t=Fn(t),this._streaming||(this._decoder=new su({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(t.stream);for(var s=new ts(r),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==Yt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===Yt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),ru(o)}};function Rn(n,e){if(!(this instanceof Rn))return new Rn(n,e);if(n=n!==void 0?String(n).toLowerCase():An,n!==An)throw new Error("Encoding not supported. Only utf-8 is supported");e=Fn(e),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(e.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}Rn.prototype={encode:function(e,t){e=e?String(e):"",t=Fn(t),this._streaming||(this._encoder=new ou(this._options)),this._streaming=Boolean(t.stream);for(var r=[],s=new ts(nu(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==Yt);)Array.isArray(o)?r.push.apply(r,o):r.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==Yt;)Array.isArray(o)?r.push.apply(r,o):r.push(o);this._encoder=null}return new Uint8Array(r)}};function su(n){var e=n.fatal,t=0,r=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===kn&&s!==0)return s=0,fr(e);if(c===kn)return Yt;if(s===0){if(dt(c,0,127))return c;if(dt(c,194,223))s=1,t=c-192;else if(dt(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(dt(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return fr(e);return t=t<<6*s,null}if(!dt(c,o,i))return t=s=r=0,o=128,i=191,a.prepend(c),fr(e);if(o=128,i=191,r+=1,t+=c-128<<6*(s-r),r!==s)return null;var u=t;return t=s=r=0,u}}function ou(n){n.fatal,this.handler=function(e,t){if(t===kn)return Yt;if(dt(t,0,127))return t;var r,s;dt(t,128,2047)?(r=1,s=192):dt(t,2048,65535)?(r=2,s=224):dt(t,65536,1114111)&&(r=3,s=240);for(var o=[(t>>6*r)+s];r>0;){var i=t>>6*(r-1);o.push(128|i&63),r-=1}return o}}var iu=Object.freeze(Object.defineProperty({__proto__:null,TextEncoder:Rn,TextDecoder:In},Symbol.toStringTag,{value:"Module"})),au=gt(iu),cu=at&&at.__createBinding||(Object.create?function(n,e,t,r){r===void 0&&(r=t),Object.defineProperty(n,r,{enumerable:!0,get:function(){return e[t]}})}:function(n,e,t,r){r===void 0&&(r=t),n[r]=e[t]}),uu=at&&at.__setModuleDefault||(Object.create?function(n,e){Object.defineProperty(n,"default",{enumerable:!0,value:e})}:function(n,e){n.default=e}),ct=at&&at.__decorate||function(n,e,t,r){var s=arguments.length,o=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(i=n[a])&&(o=(s<3?i(o):s>3?i(e,t,o):i(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o},lu=at&&at.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)t!=="default"&&Object.hasOwnProperty.call(n,t)&&cu(e,n,t);return uu(e,n),e},Ro=at&&at.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ie,"__esModule",{value:!0});var Lo=Ie.deserializeUnchecked=No=Ie.deserialize=Po=Ie.serialize=Ie.BinaryReader=Ie.BinaryWriter=Ie.BorshError=Ie.baseDecode=Ie.baseEncode=void 0;const Et=Ro(Yi.exports),To=Ro(me),fu=lu(au),du=typeof TextDecoder!="function"?fu.TextDecoder:TextDecoder,hu=new du("utf-8",{fatal:!0});function pu(n){return typeof n=="string"&&(n=Buffer.from(n,"utf8")),To.default.encode(Buffer.from(n))}Ie.baseEncode=pu;function gu(n){return Buffer.from(To.default.decode(n))}Ie.baseDecode=gu;const dr=1024;class qe extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Ie.BorshError=qe;class Co{constructor(){this.buf=Buffer.alloc(dr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(dr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Et.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Et.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Et.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Et.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(dr)]),this.length+=e.length}writeString(e){this.maybeResize();const t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const r of e)this.maybeResize(),t(r)}toArray(){return this.buf.subarray(0,this.length)}}Ie.BinaryWriter=Co;function ut(n,e,t){const r=t.value;t.value=function(...s){try{return r.apply(this,s)}catch(o){if(o instanceof RangeError){const i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new qe("Reached the end of buffer when deserializing")}throw o}}}class je{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new Et.default(e,"le")}readU128(){const e=this.readBuffer(16);return new Et.default(e,"le")}readU256(){const e=this.readBuffer(32);return new Et.default(e,"le")}readU512(){const e=this.readBuffer(64);return new Et.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new qe(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return hu.decode(t)}catch(r){throw new qe(`Error decoding UTF-8 string: ${r}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),r=Array();for(let s=0;s<t;++s)r.push(e());return r}}ct([ut],je.prototype,"readU8",null);ct([ut],je.prototype,"readU16",null);ct([ut],je.prototype,"readU32",null);ct([ut],je.prototype,"readU64",null);ct([ut],je.prototype,"readU128",null);ct([ut],je.prototype,"readU256",null);ct([ut],je.prototype,"readU512",null);ct([ut],je.prototype,"readString",null);ct([ut],je.prototype,"readFixedArray",null);ct([ut],je.prototype,"readArray",null);Ie.BinaryReader=je;function Oo(n){return n.charAt(0).toUpperCase()+n.slice(1)}function Ot(n,e,t,r,s){try{if(typeof r=="string")s[`write${Oo(r)}`](t);else if(r instanceof Array)if(typeof r[0]=="number"){if(t.length!==r[0])throw new qe(`Expecting byte array of length ${r[0]}, but got ${t.length} bytes`);s.writeFixedArray(t)}else if(r.length===2&&typeof r[1]=="number"){if(t.length!==r[1])throw new qe(`Expecting byte array of length ${r[1]}, but got ${t.length} bytes`);for(let o=0;o<r[1];o++)Ot(n,null,t[o],r[0],s)}else s.writeArray(t,o=>{Ot(n,e,o,r[0],s)});else if(r.kind!==void 0)switch(r.kind){case"option":{t==null?s.writeU8(0):(s.writeU8(1),Ot(n,e,t,r.type,s));break}case"map":{s.writeU32(t.size),t.forEach((o,i)=>{Ot(n,e,i,r.key,s),Ot(n,e,o,r.value,s)});break}default:throw new qe(`FieldType ${r} unrecognized`)}else Uo(n,t,s)}catch(o){throw o instanceof qe&&o.addToFieldPath(e),o}}function Uo(n,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const r=n.get(e.constructor);if(!r)throw new qe(`Class ${e.constructor.name} is missing in schema`);if(r.kind==="struct")r.fields.map(([s,o])=>{Ot(n,s,e[s],o,t)});else if(r.kind==="enum"){const s=e[r.field];for(let o=0;o<r.values.length;++o){const[i,a]=r.values[o];if(i===s){t.writeU8(o),Ot(n,i,e[i],a,t);break}}}else throw new qe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function yu(n,e,t=Co){const r=new t;return Uo(n,e,r),r.toArray()}var Po=Ie.serialize=yu;function Ut(n,e,t,r){try{if(typeof t=="string")return r[`read${Oo(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return r.readFixedArray(t[0]);if(typeof t[1]=="number"){const s=[];for(let o=0;o<t[1];o++)s.push(Ut(n,null,t[0],r));return s}else return r.readArray(()=>Ut(n,e,t[0],r))}if(t.kind==="option")return r.readU8()?Ut(n,e,t.type,r):void 0;if(t.kind==="map"){let s=new Map;const o=r.readU32();for(let i=0;i<o;i++){const a=Ut(n,e,t.key,r),c=Ut(n,e,t.value,r);s.set(a,c)}return s}return ns(n,t,r)}catch(s){throw s instanceof qe&&s.addToFieldPath(e),s}}function ns(n,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const r=n.get(e);if(!r)throw new qe(`Class ${e.name} is missing in schema`);if(r.kind==="struct"){const s={};for(const[o,i]of n.get(e).fields)s[o]=Ut(n,o,i,t);return new e(s)}if(r.kind==="enum"){const s=t.readU8();if(s>=r.values.length)throw new qe(`Enum index: ${s} is out of range`);const[o,i]=r.values[s],a=Ut(n,o,i,t);return new e({[o]:a})}throw new qe(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)}function mu(n,e,t,r=je){const s=new r(t),o=ns(n,e,s);if(s.offset<t.length)throw new qe(`Unexpected ${t.length-s.offset} bytes after deserialized data`);return o}var No=Ie.deserialize=mu;function bu(n,e,t,r=je){const s=new r(t);return ns(n,e,s)}Lo=Ie.deserializeUnchecked=bu;var v={};Object.defineProperty(v,"__esModule",{value:!0});v.s16=v.s8=v.nu64be=v.u48be=v.u40be=v.u32be=v.u24be=v.u16be=Ae=v.nu64=v.u48=v.u40=z=v.u32=v.u24=Ve=v.u16=ae=v.u8=Nt=v.offset=v.greedy=v.Constant=v.UTF8=v.CString=v.Blob=v.Boolean=v.BitField=v.BitStructure=v.VariantLayout=v.Union=v.UnionLayoutDiscriminator=v.UnionDiscriminator=v.Structure=v.Sequence=v.DoubleBE=v.Double=v.FloatBE=v.Float=v.NearInt64BE=v.NearInt64=v.NearUInt64BE=v.NearUInt64=v.IntBE=v.Int=v.UIntBE=v.UInt=v.OffsetLayout=v.GreedyCount=v.ExternalLayout=v.bindConstructorLayout=v.nameWithProperty=v.Layout=v.uint8ArrayToBuffer=v.checkUint8Array=void 0;v.constant=v.utf8=v.cstr=ye=v.blob=v.unionLayoutDiscriminator=v.union=De=v.seq=v.bits=D=v.struct=v.f64be=v.f64=v.f32be=v.f32=v.ns64be=v.s48be=v.s40be=v.s32be=v.s24be=v.s16be=Ke=v.ns64=v.s48=v.s40=v.s32=v.s24=void 0;const rs=Z;function Qt(n){if(!(n instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}v.checkUint8Array=Qt;function ie(n){return Qt(n),rs.Buffer.from(n.buffer,n.byteOffset,n.length)}v.uint8ArrayToBuffer=ie;class le{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}v.Layout=le;function ss(n,e){return e.property?n+"["+e.property+"]":n}v.nameWithProperty=ss;function wu(n,e){if(typeof n!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(n,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof le))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");n.layout_=e,e.boundConstructor_=n,e.makeDestinationObject=()=>new n,Object.defineProperty(n.prototype,"encode",{value(t,r){return e.encode(this,t,r)},writable:!0}),Object.defineProperty(n,"decode",{value(t,r){return e.decode(t,r)},writable:!0})}v.bindConstructorLayout=wu;class $e extends le{isCount(){throw new Error("ExternalLayout is abstract")}}v.ExternalLayout=$e;class qo extends $e{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Qt(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}v.GreedyCount=qo;class os extends $e{constructor(e,t=0,r){if(!(e instanceof le))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Ye||this.layout instanceof Qe}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}v.OffsetLayout=os;class Ye extends le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return ie(e).readUIntLE(t,this.span)}encode(e,t,r=0){return ie(t).writeUIntLE(e,r,this.span),this.span}}v.UInt=Ye;class Qe extends le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return ie(e).readUIntBE(t,this.span)}encode(e,t,r=0){return ie(t).writeUIntBE(e,r,this.span),this.span}}v.UIntBE=Qe;class Ht extends le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return ie(e).readIntLE(t,this.span)}encode(e,t,r=0){return ie(t).writeIntLE(e,r,this.span),this.span}}v.Int=Ht;class en extends le{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return ie(e).readIntBE(t,this.span)}encode(e,t,r=0){return ie(t).writeIntBE(e,r,this.span),this.span}}v.IntBE=en;const Er=Math.pow(2,32);function jn(n){const e=Math.floor(n/Er),t=n-e*Er;return{hi32:e,lo32:t}}function Wn(n,e){return n*Er+e}class Do extends le{constructor(e){super(8,e)}decode(e,t=0){const r=ie(e),s=r.readUInt32LE(t),o=r.readUInt32LE(t+4);return Wn(o,s)}encode(e,t,r=0){const s=jn(e),o=ie(t);return o.writeUInt32LE(s.lo32,r),o.writeUInt32LE(s.hi32,r+4),8}}v.NearUInt64=Do;class Ho extends le{constructor(e){super(8,e)}decode(e,t=0){const r=ie(e),s=r.readUInt32BE(t),o=r.readUInt32BE(t+4);return Wn(s,o)}encode(e,t,r=0){const s=jn(e),o=ie(t);return o.writeUInt32BE(s.hi32,r),o.writeUInt32BE(s.lo32,r+4),8}}v.NearUInt64BE=Ho;class $o extends le{constructor(e){super(8,e)}decode(e,t=0){const r=ie(e),s=r.readUInt32LE(t),o=r.readInt32LE(t+4);return Wn(o,s)}encode(e,t,r=0){const s=jn(e),o=ie(t);return o.writeUInt32LE(s.lo32,r),o.writeInt32LE(s.hi32,r+4),8}}v.NearInt64=$o;class zo extends le{constructor(e){super(8,e)}decode(e,t=0){const r=ie(e),s=r.readInt32BE(t),o=r.readUInt32BE(t+4);return Wn(s,o)}encode(e,t,r=0){const s=jn(e),o=ie(t);return o.writeInt32BE(s.hi32,r),o.writeUInt32BE(s.lo32,r+4),8}}v.NearInt64BE=zo;class Mo extends le{constructor(e){super(4,e)}decode(e,t=0){return ie(e).readFloatLE(t)}encode(e,t,r=0){return ie(t).writeFloatLE(e,r),4}}v.Float=Mo;class Ko extends le{constructor(e){super(4,e)}decode(e,t=0){return ie(e).readFloatBE(t)}encode(e,t,r=0){return ie(t).writeFloatBE(e,r),4}}v.FloatBE=Ko;class Fo extends le{constructor(e){super(8,e)}decode(e,t=0){return ie(e).readDoubleLE(t)}encode(e,t,r=0){return ie(t).writeDoubleLE(e,r),8}}v.Double=Fo;class jo extends le{constructor(e){super(8,e)}decode(e,t=0){return ie(e).readDoubleBE(t)}encode(e,t,r=0){return ie(t).writeDoubleBE(e,r),8}}v.DoubleBE=jo;class Wo extends le{constructor(e,t,r){if(!(e instanceof le))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof $e&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let s=-1;!(t instanceof $e)&&0<e.span&&(s=t*e.span),super(s,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,s=this.count;if(s instanceof $e&&(s=s.decode(e,t)),0<this.elementLayout.span)r=s*this.elementLayout.span;else{let o=0;for(;o<s;)r+=this.elementLayout.getSpan(e,t+r),++o}return r}decode(e,t=0){const r=[];let s=0,o=this.count;for(o instanceof $e&&(o=o.decode(e,t));s<o;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),s+=1;return r}encode(e,t,r=0){const s=this.elementLayout,o=e.reduce((i,a)=>i+s.encode(a,t,r+i),0);return this.count instanceof $e&&this.count.encode(e.length,t,r),o}}v.Sequence=Wo;class Vo extends le{constructor(e,t,r){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof le,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&r===void 0&&(r=t,t=void 0);for(const o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let s=-1;try{s=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(s,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce((s,o)=>{const i=o.getSpan(e,t);return t+=i,s+i},0)}catch{throw new RangeError("indeterminate span")}return r}decode(e,t=0){Qt(e);const r=this.makeDestinationObject();for(const s of this.fields)if(s.property!==void 0&&(r[s.property]=s.decode(e,t)),t+=s.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const s=r;let o=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const u=e[a.property];u!==void 0&&(i=a.encode(u,t,r),0>c&&(c=a.getSpan(t,r)))}o=r,r+=c}return o+i-s}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)r.property!==void 0&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}v.Structure=Vo;class is{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}v.UnionDiscriminator=is;class Ln extends is{constructor(e,t){if(!(e instanceof $e&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}v.UnionLayoutDiscriminator=Ln;class as extends le{constructor(e,t,r){let s;if(e instanceof Ye||e instanceof Qe)s=new Ln(new os(e));else if(e instanceof $e&&e.isCount())s=new Ln(e);else if(e instanceof is)s=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof le))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof Ye||e instanceof Qe)&&(o+=s.layout.span)),super(o,r),this.discriminator=s,this.usesPrefixDiscriminator=e instanceof Ye||e instanceof Qe,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const s=this.discriminator,o=s.decode(e,t),i=this.registry[o];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=s.layout.span),r=this.makeDestinationObject(),r[s.property]=o,r[a.property]=a.decode(e,t+c)}else r=i.decode(e,t);return r}encode(e,t,r=0){const s=this.getSourceVariant(e);if(s===void 0){const o=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,r),a+i.encode(e[i.property],t,r+a)}return s.encode(e,t,r)}addVariant(e,t,r){const s=new Go(this,e,t,r);return this.registry[e]=s,s}getVariant(e,t=0){let r;return e instanceof Uint8Array?r=this.discriminator.decode(e,t):r=e,this.registry[r]}}v.Union=as;class Go extends le{constructor(e,t,r,s){if(!(e instanceof as))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof r=="string"&&s===void 0&&(s=r,r=null),r){if(!(r instanceof le))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof s!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=r?r.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,s),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let s=0;return this.layout&&(s=this.layout.getSpan(e,t+r)),r+s}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let s=0;return this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+s):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let s=0;if(this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let o=s;if(this.layout&&(this.layout.encode(e[this.property],t,r+s),o+=this.layout.getSpan(t,r+s),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}v.VariantLayout=Go;function Ft(n){return 0>n&&(n+=4294967296),n}class cs extends le{constructor(e,t,r){if(!(e instanceof Ye||e instanceof Qe))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&r===void 0&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let s=0;this._packedSetValue=function(o){return s=Ft(o),this},this._packedGetValue=function(){return s}}decode(e,t=0){const r=this.makeDestinationObject(),s=this.word.decode(e,t);this._packedSetValue(s);for(const o of this.fields)o.property!==void 0&&(r[o.property]=o.decode(e));return r}encode(e,t,r=0){const s=this.word.decode(t,r);this._packedSetValue(s);for(const o of this.fields)if(o.property!==void 0){const i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new us(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new Zo(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}v.BitStructure=cs;class us{constructor(e,t,r){if(!(e instanceof cs))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const s=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>s)throw new Error("bits too long for span remainder ("+(s-o)+" of "+s+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=s-o-t),this.wordMask=Ft(this.valueMask<<this.start),this.property=r}decode(e,t){const r=this.container._packedGetValue();return Ft(r&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Ft(e&this.valueMask))throw new TypeError(ss("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=Ft(e<<this.start);this.container._packedSetValue(Ft(t&~this.wordMask)|r)}}v.BitField=us;class Zo extends us{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}}v.Boolean=Zo;class Yo extends le{constructor(e,t){if(!(e instanceof $e&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof $e||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),ie(e).slice(t,t+r)}encode(e,t,r){let s=this.length;if(this.length instanceof $e&&(s=e.length),!(e instanceof Uint8Array&&s===e.length))throw new TypeError(ss("Blob.encode",this)+" requires (length "+s+") Uint8Array as src");if(r+s>t.length)throw new RangeError("encoding overruns Uint8Array");const o=ie(e);return ie(t).write(o.toString("hex"),r,s,"hex"),this.length instanceof $e&&this.length.encode(s,t,r),s}}v.Blob=Yo;class Xo extends le{constructor(e){super(-1,e)}getSpan(e,t=0){Qt(e);let r=t;for(;r<e.length&&e[r]!==0;)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return ie(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const s=rs.Buffer.from(e,"utf8"),o=s.length;if(r+o>t.length)throw new RangeError("encoding overruns Buffer");const i=ie(t);return s.copy(i,r),i[r+o]=0,o+1}}v.CString=Xo;class Jo extends le{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Qt(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return ie(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){typeof e!="string"&&(e=String(e));const s=rs.Buffer.from(e,"utf8"),o=s.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(r+o>t.length)throw new RangeError("encoding overruns Buffer");return s.copy(ie(t),r),o}}v.UTF8=Jo;class Qo extends le{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}v.Constant=Qo;v.greedy=(n,e)=>new qo(n,e);var Nt=v.offset=(n,e,t)=>new os(n,e,t),ae=v.u8=n=>new Ye(1,n),Ve=v.u16=n=>new Ye(2,n);v.u24=n=>new Ye(3,n);var z=v.u32=n=>new Ye(4,n);v.u40=n=>new Ye(5,n);v.u48=n=>new Ye(6,n);var Ae=v.nu64=n=>new Do(n);v.u16be=n=>new Qe(2,n);v.u24be=n=>new Qe(3,n);v.u32be=n=>new Qe(4,n);v.u40be=n=>new Qe(5,n);v.u48be=n=>new Qe(6,n);v.nu64be=n=>new Ho(n);v.s8=n=>new Ht(1,n);v.s16=n=>new Ht(2,n);v.s24=n=>new Ht(3,n);v.s32=n=>new Ht(4,n);v.s40=n=>new Ht(5,n);v.s48=n=>new Ht(6,n);var Ke=v.ns64=n=>new $o(n);v.s16be=n=>new en(2,n);v.s24be=n=>new en(3,n);v.s32be=n=>new en(4,n);v.s40be=n=>new en(5,n);v.s48be=n=>new en(6,n);v.ns64be=n=>new zo(n);v.f32=n=>new Mo(n);v.f32be=n=>new Ko(n);v.f64=n=>new Fo(n);v.f64be=n=>new jo(n);var D=v.struct=(n,e,t)=>new Vo(n,e,t);v.bits=(n,e,t)=>new cs(n,e,t);var De=v.seq=(n,e,t)=>new Wo(n,e,t);v.union=(n,e,t)=>new as(n,e,t);v.unionLayoutDiscriminator=(n,e)=>new Ln(n,e);var ye=v.blob=(n,e)=>new Yo(n,e);v.cstr=n=>new Xo(n);v.utf8=(n,e)=>new Jo(n,e);v.constant=(n,e)=>new Qo(n,e);var yn={};Object.defineProperty(yn,"__esModule",{value:!0});function xu(n){{const e=Buffer.from(n);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var Su=yn.toBigIntLE=xu;function vu(n){{const e=n.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}yn.toBigIntBE=vu;function Eu(n,e){{const t=n.toString(16),r=Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return r.reverse(),r}}var _u=yn.toBufferLE=Eu;function Bu(n,e){{const t=n.toString(16);return Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}yn.toBufferBE=Bu;class ku extends TypeError{constructor(e,t){let r;const{message:s,...o}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function Au(n){return Bt(n)&&typeof n[Symbol.iterator]=="function"}function Bt(n){return typeof n=="object"&&n!=null}function et(n){return typeof n=="string"?JSON.stringify(n):""+n}function Iu(n){const{done:e,value:t}=n.next();return e?void 0:t}function Ru(n,e,t,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+et(r)+"`"}=n;return{value:r,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...n,message:c}}function*Ms(n,e,t,r){Au(n)||(n=[n]);for(const s of n){const o=Ru(s,e,t,r);o&&(yield o)}}function*ls(n,e,t={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:i=!1}=t,a={path:r,branch:s};if(o&&(n=e.coercer(n,a),i&&e.type!=="type"&&Bt(e.schema)&&Bt(n)&&!Array.isArray(n)))for(const u in n)e.schema[u]===void 0&&delete n[u];let c=!0;for(const u of e.validator(n,a))c=!1,yield[u,void 0];for(let[u,l,d]of e.entries(n,a)){const S=ls(l,d,{path:u===void 0?r:[...r,u],branch:u===void 0?s:[...s,l],coerce:o,mask:i});for(const g of S)g[0]?(c=!1,yield[g[0],void 0]):o&&(l=g[1],u===void 0?n=l:n instanceof Map?n.set(u,l):n instanceof Set?n.add(l):Bt(n)&&(n[u]=l))}if(c)for(const u of e.refiner(n,a))c=!1,yield[u,void 0];c&&(yield[void 0,n])}class lt{constructor(e){const{type:t,schema:r,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=i,s?this.validator=(c,u)=>{const l=s(c,u);return Ms(l,u,this,c)}:this.validator=()=>[],o?this.refiner=(c,u)=>{const l=o(c,u);return Ms(l,u,this,c)}:this.refiner=()=>[]}assert(e){return Lu(e,this)}create(e){return C(e,this)}is(e){return ei(e,this)}mask(e){return Tu(e,this)}validate(e,t={}){return mn(e,this,t)}}function Lu(n,e){const t=mn(n,e);if(t[0])throw t[0]}function C(n,e){const t=mn(n,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Tu(n,e){const t=mn(n,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function ei(n,e){return!mn(n,e)[0]}function mn(n,e,t={}){const r=ls(n,e,t),s=Iu(r);if(s[0])return[new ku(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0];{const o=s[1];return[void 0,o]}}function $t(n,e){return new lt({type:n,schema:null,validator:e})}function Cu(){return $t("any",()=>!0)}function O(n){return new lt({type:"array",schema:n,*entries(e){if(n&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,n]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+et(e)}})}function pt(){return $t("boolean",n=>typeof n=="boolean")}function fs(n){return $t("instance",e=>e instanceof n||"Expected a `"+n.name+"` instance, but received: "+et(e))}function he(n){const e=et(n),t=typeof n;return new lt({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?n:null,validator(r){return r===n||"Expected the literal `"+e+"`, but received: "+et(r)}})}function Ou(){return $t("never",()=>!1)}function U(n){return new lt({...n,validator:(e,t)=>e===null||n.validator(e,t),refiner:(e,t)=>e===null||n.refiner(e,t)})}function x(){return $t("number",n=>typeof n=="number"&&!isNaN(n)||"Expected a number, but received: "+et(n))}function j(n){return new lt({...n,validator:(e,t)=>e===void 0||n.validator(e,t),refiner:(e,t)=>e===void 0||n.refiner(e,t)})}function ti(n,e){return new lt({type:"record",schema:null,*entries(t){if(Bt(t))for(const r in t){const s=t[r];yield[r,r,n],yield[r,s,e]}},validator(t){return Bt(t)||"Expected an object, but received: "+et(t)}})}function L(){return $t("string",n=>typeof n=="string"||"Expected a string, but received: "+et(n))}function ds(n){const e=Ou();return new lt({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(n.length,t.length);for(let s=0;s<r;s++)yield[s,t[s],n[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+et(t)}})}function I(n){const e=Object.keys(n);return new lt({type:"type",schema:n,*entries(t){if(Bt(t))for(const r of e)yield[r,t[r],n[r]]},validator(t){return Bt(t)||"Expected an object, but received: "+et(t)}})}function ze(n){const e=n.map(t=>t.type).join(" | ");return new lt({type:"union",schema:null,validator(t,r){const s=[];for(const o of n){const[...i]=ls(t,o,r),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+et(t),...s]}})}function bn(){return $t("unknown",()=>!0)}function wn(n,e,t){return new lt({...n,coercer:(r,s)=>ei(r,e)?n.coercer(t(r,s),s):n.coercer(r,s)})}var ni=gt(_a);const Uu=ni.v4,Pu=function(n,e,t,r){if(typeof n!="string")throw new TypeError(n+" must be a string");r=r||{};const s=typeof r.version=="number"?r.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const o={method:n};if(s===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t=="undefined"){const i=typeof r.generator=="function"?r.generator:function(){return Uu()};o.id=i(o,r)}else s===2&&t===null?r.notificationIdNull&&(o.id=null):o.id=t;return o};var Nu=Pu;const qu=ni.v4,Du=Nu,dn=function(n,e){if(!(this instanceof dn))return new dn(n,e);e||(e={}),this.options={reviver:typeof e.reviver!="undefined"?e.reviver:null,replacer:typeof e.replacer!="undefined"?e.replacer:null,generator:typeof e.generator!="undefined"?e.generator:function(){return qu()},version:typeof e.version!="undefined"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=n};var Hu=dn;dn.prototype.request=function(n,e,t,r){const s=this;let o=null;const i=Array.isArray(n)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&n&&typeof n=="object"&&typeof e=="function")r=e,o=n;else{typeof t=="function"&&(r=t,t=void 0);const u=typeof r=="function";try{o=Du(n,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(l){if(u)return r(l);throw l}if(!u)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(u){return r(u)}return this.callServer(c,function(u,l){s._parseResponse(u,l,r)}),o};dn.prototype._parseResponse=function(n,e,t){if(n){t(n);return}if(!e)return t();let r;try{r=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(r)){const s=function(i){return typeof i.error!="undefined"},o=function(i){return!s(i)};return t(null,r.filter(s),r.filter(o))}else return t(null,r.error,r.result);t(null,r)};var ri={},hs={exports:{}};(function(n){function e(t){return t&&t.__esModule?t:{default:t}}n.exports=e,n.exports.__esModule=!0,n.exports.default=n.exports})(hs);var $u=gt(oa),zu=gt(Xi),si=gt(Ji),oi=gt(Qi),ii=gt(ea),ai=gt(ta),ci=gt(na);(function(n){var e=hs.exports;Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var t=e(ia),r=e($u),s=e(zu),o=e(si),i=e(oi),a=e(ii),c=e(ai),u=e(ci),l=oo.exports;function d(f){var h=S();return function(){var b=(0,u.default)(f),p;if(h){var E=(0,u.default)(this).constructor;p=Reflect.construct(b,arguments,E)}else p=b.apply(this,arguments);return(0,c.default)(this,p)}}function S(){if(typeof Reflect=="undefined"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var g=function(f,h){var m={};for(var b in f)Object.prototype.hasOwnProperty.call(f,b)&&h.indexOf(b)<0&&(m[b]=f[b]);if(f!=null&&typeof Object.getOwnPropertySymbols=="function")for(var p=0,b=Object.getOwnPropertySymbols(f);p<b.length;p++)h.indexOf(b[p])<0&&Object.prototype.propertyIsEnumerable.call(f,b[p])&&(m[b[p]]=f[b[p]]);return m},y=function(f){(0,a.default)(m,f);var h=d(m);function m(b){var p,E=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",w=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},_=arguments.length>3?arguments[3]:void 0;(0,o.default)(this,m);var B=w.autoconnect,A=B===void 0?!0:B,F=w.reconnect,W=F===void 0?!0:F,K=w.reconnect_interval,se=K===void 0?1e3:K,ee=w.max_reconnects,Re=ee===void 0?5:ee,R=g(w,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return p=h.call(this),p.webSocketFactory=b,p.queue={},p.rpc_id=0,p.address=E,p.autoconnect=A,p.ready=!1,p.reconnect=W,p.reconnect_timer_id=void 0,p.reconnect_interval=se,p.max_reconnects=Re,p.rest_options=R,p.current_reconnects=0,p.generate_request_id=_||function(){return++p.rpc_id},p.autoconnect&&p._connect(p.address,Object.assign({autoconnect:p.autoconnect,reconnect:p.reconnect,reconnect_interval:p.reconnect_interval,max_reconnects:p.max_reconnects},p.rest_options)),p}return(0,i.default)(m,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(p,E,w,_){var B=this;return!_&&(0,s.default)(w)==="object"&&(_=w,w=null),new Promise(function(A,F){if(!B.ready)return F(new Error("socket not ready"));var W=B.generate_request_id(p,E),K={jsonrpc:"2.0",method:p,params:E||null,id:W};B.socket.send(JSON.stringify(K),_,function(se){if(se)return F(se);B.queue[W]={promise:[A,F]},w&&(B.queue[W].timeout=setTimeout(function(){delete B.queue[W],F(new Error("reply timeout"))},w))})})}},{key:"login",value:function(){var b=(0,r.default)(t.default.mark(function E(w){var _;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.call("rpc.login",w);case 2:if(_=A.sent,_){A.next=5;break}throw new Error("authentication failed");case 5:return A.abrupt("return",_);case 6:case"end":return A.stop()}},E,this)}));function p(E){return b.apply(this,arguments)}return p}()},{key:"listMethods",value:function(){var b=(0,r.default)(t.default.mark(function E(){return t.default.wrap(function(_){for(;;)switch(_.prev=_.next){case 0:return _.next=2,this.call("__listMethods");case 2:return _.abrupt("return",_.sent);case 3:case"end":return _.stop()}},E,this)}));function p(){return b.apply(this,arguments)}return p}()},{key:"notify",value:function(p,E){var w=this;return new Promise(function(_,B){if(!w.ready)return B(new Error("socket not ready"));var A={jsonrpc:"2.0",method:p,params:E||null};w.socket.send(JSON.stringify(A),function(F){if(F)return B(F);_()})})}},{key:"subscribe",value:function(){var b=(0,r.default)(t.default.mark(function E(w){var _;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return typeof w=="string"&&(w=[w]),A.next=3,this.call("rpc.on",w);case 3:if(_=A.sent,!(typeof w=="string"&&_[w]!=="ok")){A.next=6;break}throw new Error("Failed subscribing to an event '"+w+"' with: "+_[w]);case 6:return A.abrupt("return",_);case 7:case"end":return A.stop()}},E,this)}));function p(E){return b.apply(this,arguments)}return p}()},{key:"unsubscribe",value:function(){var b=(0,r.default)(t.default.mark(function E(w){var _;return t.default.wrap(function(A){for(;;)switch(A.prev=A.next){case 0:return typeof w=="string"&&(w=[w]),A.next=3,this.call("rpc.off",w);case 3:if(_=A.sent,!(typeof w=="string"&&_[w]!=="ok")){A.next=6;break}throw new Error("Failed unsubscribing from an event with: "+_);case 6:return A.abrupt("return",_);case 7:case"end":return A.stop()}},E,this)}));function p(E){return b.apply(this,arguments)}return p}()},{key:"close",value:function(p,E){this.socket.close(p||1e3,E)}},{key:"_connect",value:function(p,E){var w=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(p,E),this.socket.addEventListener("open",function(){w.ready=!0,w.emit("open"),w.current_reconnects=0}),this.socket.addEventListener("message",function(_){var B=_.data;B instanceof ArrayBuffer&&(B=Buffer.from(B).toString());try{B=JSON.parse(B)}catch{return}if(B.notification&&w.listeners(B.notification).length){if(!Object.keys(B.params).length)return w.emit(B.notification);var A=[B.notification];if(B.params.constructor===Object)A.push(B.params);else for(var F=0;F<B.params.length;F++)A.push(B.params[F]);return Promise.resolve().then(function(){w.emit.apply(w,A)})}if(!w.queue[B.id])return B.method&&B.params?Promise.resolve().then(function(){w.emit(B.method,B.params)}):void 0;"error"in B=="result"in B&&w.queue[B.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),w.queue[B.id].timeout&&clearTimeout(w.queue[B.id].timeout),B.error?w.queue[B.id].promise[1](B.error):w.queue[B.id].promise[0](B.result),delete w.queue[B.id]}),this.socket.addEventListener("error",function(_){return w.emit("error",_)}),this.socket.addEventListener("close",function(_){var B=_.code,A=_.reason;w.ready&&setTimeout(function(){return w.emit("close",B,A)},0),w.ready=!1,w.socket=void 0,B!==1e3&&(w.current_reconnects++,w.reconnect&&(w.max_reconnects>w.current_reconnects||w.max_reconnects===0)&&(w.reconnect_timer_id=setTimeout(function(){return w._connect(p,E)},w.reconnect_interval)))})}}]),m}(l.EventEmitter);n.default=y})(ri);var Mu=io(ri),ui={};(function(n){var e=hs.exports;Object.defineProperty(n,"__esModule",{value:!0}),n.default=d;var t=e(si),r=e(oi),s=e(ii),o=e(ai),i=e(ci),a=oo.exports;function c(S){var g=u();return function(){var f=(0,i.default)(S),h;if(g){var m=(0,i.default)(this).constructor;h=Reflect.construct(f,arguments,m)}else h=f.apply(this,arguments);return(0,o.default)(this,h)}}function u(){if(typeof Reflect=="undefined"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var l=function(S){(0,s.default)(y,S);var g=c(y);function y(f,h,m){var b;return(0,t.default)(this,y),b=g.call(this),b.socket=new window.WebSocket(f,m),b.socket.onopen=function(){return b.emit("open")},b.socket.onmessage=function(p){return b.emit("message",p.data)},b.socket.onerror=function(p){return b.emit("error",p)},b.socket.onclose=function(p){b.emit("close",p.code,p.reason)},b}return(0,r.default)(y,[{key:"send",value:function(h,m,b){var p=b||m;try{this.socket.send(h),p()}catch(E){p(E)}}},{key:"close",value:function(h,m){this.socket.close(h,m)}},{key:"addEventListener",value:function(h,m,b){this.socket.addEventListener(h,m,b)}}]),y}(a.EventEmitter);function d(S,g){return new l(S,g)}})(ui);var Ku=io(ui);const[li,fi,di]=[[],[],[]],Fu=BigInt(0),on=BigInt(1),ju=BigInt(2),Wu=BigInt(7),Vu=BigInt(256),Gu=BigInt(113);for(let n=0,e=on,t=1,r=0;n<24;n++){[t,r]=[r,(2*t+3*r)%5],li.push(2*(5*r+t)),fi.push((n+1)*(n+2)/2%64);let s=Fu;for(let o=0;o<7;o++)e=(e<<on^(e>>Wu)*Gu)%Vu,e&ju&&(s^=on<<(on<<BigInt(o))-on);di.push(s)}const[Zu,Yu]=G.split(di,!0),Ks=(n,e,t)=>t>32?G.rotlBH(n,e,t):G.rotlSH(n,e,t),Fs=(n,e,t)=>t>32?G.rotlBL(n,e,t):G.rotlSL(n,e,t);function Xu(n,e=24){const t=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let i=0;i<10;i++)t[i]=n[i]^n[i+10]^n[i+20]^n[i+30]^n[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,u=t[c],l=t[c+1],d=Ks(u,l,1)^t[a],S=Fs(u,l,1)^t[a+1];for(let g=0;g<50;g+=10)n[i+g]^=d,n[i+g+1]^=S}let s=n[2],o=n[3];for(let i=0;i<24;i++){const a=fi[i],c=Ks(s,o,a),u=Fs(s,o,a),l=li[i];s=n[l],o=n[l+1],n[l]=c,n[l+1]=u}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=n[i+a];for(let a=0;a<10;a++)n[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}n[0]^=Zu[r],n[1]^=Yu[r]}t.fill(0)}class Vn extends jr{constructor(e,t,r,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Fe.number(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ra(this.state)}keccak(){Xu(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){Fe.exists(this);const{blockLen:t,state:r}=this;e=gn(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(t-this.pos,s-o);for(let a=0;a<i;a++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:s}=this;e[r]^=t,(t&128)!==0&&r===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){Fe.exists(this,!1),Fe.bytes(e),this.finish();const t=this.state,{blockLen:r}=this;for(let s=0,o=e.length;s<o;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,o-s);e.set(t.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Fe.number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Fe.output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new Vn(t,r,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=r,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}}const Lt=(n,e,t)=>Dt(()=>new Vn(e,n,t));Lt(6,144,224/8);Lt(6,136,256/8);Lt(6,104,384/8);Lt(6,72,512/8);Lt(1,144,224/8);Lt(1,136,256/8);Lt(1,104,384/8);Lt(1,72,512/8);const hi=(n,e,t)=>Ta((r={})=>new Vn(e,n,r.dkLen===void 0?t:r.dkLen,!0));hi(31,168,128/8);hi(31,136,256/8);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ju(n){const e=Yr(n);Rt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Qu,hexToBytes:el}=dc,Pt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=Pt;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Qu(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=Pt,t=typeof n=="string"?el(n):n;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=Pt._parseInt(t.subarray(2)),{d:i,l:a}=Pt._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(n){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},r=e(t(n.s)),s=e(t(n.r)),o=r.length/2,i=s.length/2,a=t(o),c=t(i);return`30${t(i+o+4)}02${c}${s}02${a}${r}`}},Je=BigInt(0),ve=BigInt(1),ft=BigInt(2),Tn=BigInt(3),js=BigInt(4);function tl(n){const e=Ju(n),{Fp:t}=e,r=e.toBytes||((y,f,h)=>{const m=f.toAffine();return Ne(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),s=e.fromBytes||(y=>{const f=y.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),m=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y:m}});function o(y){const{a:f,b:h}=e,m=t.sqr(y),b=t.mul(m,y);return t.add(t.add(b,t.mul(y,f)),h)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(y){return typeof y=="bigint"&&Je<y&&y<e.n}function a(y){if(!i(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:m,n:b}=e;if(f&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=kt(y)),typeof y!="string"||!f.includes(y.length))throw new Error("Invalid key");y=y.padStart(h*2,"0")}let p;try{p=typeof y=="bigint"?y:He(ue("private key",y,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof y}`)}return m&&(p=ce(p,b)),a(p),p}const u=new Map;function l(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}class d{constructor(f,h,m){if(this.px=f,this.py=h,this.pz=m,f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required")}static fromAffine(f){const{x:h,y:m}=f||{};if(!f||!t.isValid(h)||!t.isValid(m))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const b=p=>t.eql(p,t.ZERO);return b(h)&&b(m)?d.ZERO:new d(h,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=t.invertBatch(f.map(m=>m.pz));return f.map((m,b)=>m.toAffine(h[b])).map(d.fromAffine)}static fromHex(f){const h=d.fromAffine(s(ue("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return d.BASE.multiply(c(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:f,y:h}=this.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");const m=t.sqr(h),b=o(f);if(!t.eql(m,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){l(f);const{px:h,py:m,pz:b}=this,{px:p,py:E,pz:w}=f,_=t.eql(t.mul(h,w),t.mul(p,b)),B=t.eql(t.mul(m,w),t.mul(E,b));return _&&B}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=e,m=t.mul(h,Tn),{px:b,py:p,pz:E}=this;let w=t.ZERO,_=t.ZERO,B=t.ZERO,A=t.mul(b,b),F=t.mul(p,p),W=t.mul(E,E),K=t.mul(b,p);return K=t.add(K,K),B=t.mul(b,E),B=t.add(B,B),w=t.mul(f,B),_=t.mul(m,W),_=t.add(w,_),w=t.sub(F,_),_=t.add(F,_),_=t.mul(w,_),w=t.mul(K,w),B=t.mul(m,B),W=t.mul(f,W),K=t.sub(A,W),K=t.mul(f,K),K=t.add(K,B),B=t.add(A,A),A=t.add(B,A),A=t.add(A,W),A=t.mul(A,K),_=t.add(_,A),W=t.mul(p,E),W=t.add(W,W),A=t.mul(W,K),w=t.sub(w,A),B=t.mul(W,F),B=t.add(B,B),B=t.add(B,B),new d(w,_,B)}add(f){l(f);const{px:h,py:m,pz:b}=this,{px:p,py:E,pz:w}=f;let _=t.ZERO,B=t.ZERO,A=t.ZERO;const F=e.a,W=t.mul(e.b,Tn);let K=t.mul(h,p),se=t.mul(m,E),ee=t.mul(b,w),Re=t.add(h,m),R=t.add(p,E);Re=t.mul(Re,R),R=t.add(K,se),Re=t.sub(Re,R),R=t.add(h,b);let N=t.add(p,w);return R=t.mul(R,N),N=t.add(K,ee),R=t.sub(R,N),N=t.add(m,b),_=t.add(E,w),N=t.mul(N,_),_=t.add(se,ee),N=t.sub(N,_),A=t.mul(F,R),_=t.mul(W,ee),A=t.add(_,A),_=t.sub(se,A),A=t.add(se,A),B=t.mul(_,A),se=t.add(K,K),se=t.add(se,K),ee=t.mul(F,ee),R=t.mul(W,R),se=t.add(se,ee),ee=t.sub(K,ee),ee=t.mul(F,ee),R=t.add(R,ee),K=t.mul(se,R),B=t.add(B,K),K=t.mul(N,R),_=t.mul(Re,_),_=t.sub(_,K),K=t.mul(Re,se),A=t.mul(N,A),A=t.add(A,K),new d(_,B,A)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return g.wNAFCached(this,u,f,h=>{const m=t.invertBatch(h.map(b=>b.pz));return h.map((b,p)=>b.toAffine(m[p])).map(d.fromAffine)})}multiplyUnsafe(f){const h=d.ZERO;if(f===Je)return h;if(a(f),f===ve)return this;const{endo:m}=e;if(!m)return g.unsafeLadder(this,f);let{k1neg:b,k1:p,k2neg:E,k2:w}=m.splitScalar(f),_=h,B=h,A=this;for(;p>Je||w>Je;)p&ve&&(_=_.add(A)),w&ve&&(B=B.add(A)),A=A.double(),p>>=ve,w>>=ve;return b&&(_=_.negate()),E&&(B=B.negate()),B=new d(t.mul(B.px,m.beta),B.py,B.pz),_.add(B)}multiply(f){a(f);let h=f,m,b;const{endo:p}=e;if(p){const{k1neg:E,k1:w,k2neg:_,k2:B}=p.splitScalar(h);let{p:A,f:F}=this.wNAF(w),{p:W,f:K}=this.wNAF(B);A=g.constTimeNegate(E,A),W=g.constTimeNegate(_,W),W=new d(t.mul(W.px,p.beta),W.py,W.pz),m=A.add(W),b=F.add(K)}else{const{p:E,f:w}=this.wNAF(h);m=E,b=w}return d.normalizeZ([m,b])[0]}multiplyAndAddUnsafe(f,h,m){const b=d.BASE,p=(w,_)=>_===Je||_===ve||!w.equals(b)?w.multiplyUnsafe(_):w.multiply(_),E=p(this,h).add(p(f,m));return E.is0()?void 0:E}toAffine(f){const{px:h,py:m,pz:b}=this,p=this.is0();f==null&&(f=p?t.ONE:t.inv(b));const E=t.mul(h,f),w=t.mul(m,f),_=t.mul(b,f);if(p)return{x:t.ZERO,y:t.ZERO};if(!t.eql(_,t.ONE))throw new Error("invZ was invalid");return{x:E,y:w}}isTorsionFree(){const{h:f,isTorsionFree:h}=e;if(f===ve)return!0;if(h)return h(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=e;return f===ve?this:h?h(d,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),r(d,this,f)}toHex(f=!0){return kt(this.toRawBytes(f))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const S=e.nBitLength,g=Eo(d,e.endo?Math.ceil(S/2):S);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:i}}function nl(n){const e=Yr(n);return Rt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function rl(n){const e=nl(n),{Fp:t,n:r}=e,s=t.BYTES+1,o=2*t.BYTES+1;function i(R){return Je<R&&R<t.ORDER}function a(R){return ce(R,r)}function c(R){return xr(R,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:S}=tl({...e,toBytes(R,N,Y){const T=N.toAffine(),k=t.toBytes(T.x),q=Ne;return Y?q(Uint8Array.from([N.hasEvenY()?2:3]),k):q(Uint8Array.from([4]),k,t.toBytes(T.y))},fromBytes(R){const N=R.length,Y=R[0],T=R.subarray(1);if(N===s&&(Y===2||Y===3)){const k=He(T);if(!i(k))throw new Error("Point is not on curve");const q=d(k);let $=t.sqrt(q);const V=($&ve)===ve;return(Y&1)===1!==V&&($=t.neg($)),{x:k,y:$}}else if(N===o&&Y===4){const k=t.fromBytes(T.subarray(0,t.BYTES)),q=t.fromBytes(T.subarray(t.BYTES,2*t.BYTES));return{x:k,y:q}}else throw new Error(`Point of length ${N} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),g=R=>kt(_t(R,e.nByteLength));function y(R){const N=r>>ve;return R>N}function f(R){return y(R)?a(-R):R}const h=(R,N,Y)=>He(R.slice(N,Y));class m{constructor(N,Y,T){this.r=N,this.s=Y,this.recovery=T,this.assertValidity()}static fromCompact(N){const Y=e.nByteLength;return N=ue("compactSignature",N,Y*2),new m(h(N,0,Y),h(N,Y,2*Y))}static fromDER(N){const{r:Y,s:T}=Pt.toSig(ue("DER",N));return new m(Y,T)}assertValidity(){if(!S(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!S(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(N){return new m(this.r,this.s,N)}recoverPublicKey(N){const{r:Y,s:T,recovery:k}=this,q=B(ue("msgHash",N));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const $=k===2||k===3?Y+e.n:Y;if($>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=(k&1)===0?"02":"03",J=u.fromHex(V+g($)),Q=c($),oe=a(-q*Q),ne=a(T*Q),re=u.BASE.multiplyAndAddUnsafe(J,oe,ne);if(!re)throw new Error("point at infinify");return re.assertValidity(),re}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Gt(this.toDERHex())}toDERHex(){return Pt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Gt(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const b={isValidPrivateKey(R){try{return l(R),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const R=e.randomBytes(t.BYTES+8),N=xc(R,r);return _t(N,e.nByteLength)},precompute(R=8,N=u.BASE){return N._setWindowSize(R),N.multiply(BigInt(3)),N}};function p(R,N=!0){return u.fromPrivateKey(R).toRawBytes(N)}function E(R){const N=R instanceof Uint8Array,Y=typeof R=="string",T=(N||Y)&&R.length;return N?T===s||T===o:Y?T===2*s||T===2*o:R instanceof u}function w(R,N,Y=!0){if(E(R))throw new Error("first arg must be private key");if(!E(N))throw new Error("second arg must be public key");return u.fromHex(N).multiply(l(R)).toRawBytes(Y)}const _=e.bits2int||function(R){const N=He(R),Y=R.length*8-e.nBitLength;return Y>0?N>>BigInt(Y):N},B=e.bits2int_modN||function(R){return a(_(R))},A=Gr(e.nBitLength);function F(R){if(typeof R!="bigint")throw new Error("bigint expected");if(!(Je<=R&&R<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return _t(R,e.nByteLength)}function W(R,N,Y=K){if(["recovered","canonical"].some(ge=>ge in Y))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:k}=e;let{lowS:q,prehash:$,extraEntropy:V}=Y;q==null&&(q=!0),R=ue("msgHash",R),$&&(R=ue("prehashed msgHash",T(R)));const J=B(R),Q=l(N),oe=[F(Q),F(J)];if(V!=null){const ge=V===!0?k(t.BYTES):V;oe.push(ue("extraEntropy",ge,t.BYTES))}const ne=Ne(...oe),re=J;function be(ge){const ke=_(ge);if(!S(ke))return;const Le=c(ke),Pe=u.BASE.multiply(ke).toAffine(),_e=a(Pe.x);if(_e===Je)return;const Xe=a(Le*a(re+_e*Q));if(Xe===Je)return;let Tt=(Pe.x===_e?0:2)|Number(Pe.y&ve),rn=Xe;return q&&y(Xe)&&(rn=f(Xe),Tt^=1),new m(_e,rn,Tt)}return{seed:ne,k2sig:be}}const K={lowS:e.lowS,prehash:!1},se={lowS:e.lowS,prehash:!1};function ee(R,N,Y=K){const{seed:T,k2sig:k}=W(R,N,Y);return wo(e.hash.outputLen,e.nByteLength,e.hmac)(T,k)}u.BASE._setWindowSize(8);function Re(R,N,Y,T=se){var Pe;const k=R;if(N=ue("msgHash",N),Y=ue("publicKey",Y),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:q,prehash:$}=T;let V,J;try{if(typeof k=="string"||k instanceof Uint8Array)try{V=m.fromDER(k)}catch(_e){if(!(_e instanceof Pt.Err))throw _e;V=m.fromCompact(k)}else if(typeof k=="object"&&typeof k.r=="bigint"&&typeof k.s=="bigint"){const{r:_e,s:Xe}=k;V=new m(_e,Xe)}else throw new Error("PARSE");J=u.fromHex(Y)}catch(_e){if(_e.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(q&&V.hasHighS())return!1;$&&(N=e.hash(N));const{r:Q,s:oe}=V,ne=B(N),re=c(oe),be=a(ne*re),ge=a(Q*re),ke=(Pe=u.BASE.multiplyAndAddUnsafe(J,be,ge))==null?void 0:Pe.toAffine();return ke?a(ke.x)===Q:!1}return{CURVE:e,getPublicKey:p,getSharedSecret:w,sign:ee,verify:Re,ProjectivePoint:u,Signature:m,utils:b}}function sl(n,e){const t=n.ORDER;let r=Je;for(let S=t-ve;S%ft===Je;S/=ft)r+=ve;const s=r,o=(t-ve)/ft**s,i=(o-ve)/ft,a=ft**s-ve,c=ft**(s-ve),u=n.pow(e,o),l=n.pow(e,(o+ve)/ft);let d=(S,g)=>{let y=u,f=n.pow(g,a),h=n.sqr(f);h=n.mul(h,g);let m=n.mul(S,h);m=n.pow(m,i),m=n.mul(m,f),f=n.mul(m,g),h=n.mul(m,S);let b=n.mul(h,f);m=n.pow(b,c);let p=n.eql(m,n.ONE);f=n.mul(h,l),m=n.mul(b,y),h=n.cmov(f,h,p),b=n.cmov(m,b,p);for(let E=s;E>ve;E--){let w=ft**(E-ft),_=n.pow(b,w);const B=n.eql(_,n.ONE);f=n.mul(h,y),y=n.mul(y,y),_=n.mul(b,y),h=n.cmov(f,h,B),b=n.cmov(_,b,B)}return{isValid:p,value:h}};if(n.ORDER%js===Tn){const S=(n.ORDER-Tn)/js,g=n.sqrt(n.neg(e));d=(y,f)=>{let h=n.sqr(f);const m=n.mul(y,f);h=n.mul(h,m);let b=n.pow(h,S);b=n.mul(b,m);const p=n.mul(b,g),E=n.mul(n.sqr(b),f),w=n.eql(E,y);let _=n.cmov(p,b,w);return{isValid:w,value:_}}}return d}function ol(n,e){if(So(n),!n.isValid(e.A)||!n.isValid(e.B)||!n.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=sl(n,e.Z);if(!n.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,i,a,c,u,l,d;s=n.sqr(r),s=n.mul(s,e.Z),o=n.sqr(s),o=n.add(o,s),i=n.add(o,n.ONE),i=n.mul(i,e.B),a=n.cmov(e.Z,n.neg(o),!n.eql(o,n.ZERO)),a=n.mul(a,e.A),o=n.sqr(i),u=n.sqr(a),c=n.mul(u,e.A),o=n.add(o,c),o=n.mul(o,i),u=n.mul(u,a),c=n.mul(u,e.B),o=n.add(o,c),l=n.mul(s,i);const{isValid:S,value:g}=t(o,u);d=n.mul(s,r),d=n.mul(d,g),l=n.cmov(l,i,S),d=n.cmov(d,g,S);const y=n.isOdd(r)===n.isOdd(d);return d=n.cmov(n.neg(d),d,y),l=n.div(l,a),{x:l,y:d}}}class pi extends jr{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Fe.hash(e);const r=gn(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Fe.exists(this),this.iHash.update(e),this}digestInto(e){Fe.exists(this),Fe.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const gi=(n,e,t)=>new pi(n,e).update(t).digest();gi.create=(n,e)=>new pi(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function il(n){return{hash:n,hmac:(e,...t)=>gi(n,e,ho(...t)),randomBytes:Hn}}function al(n,e){const t=r=>rl({...n,...il(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Cn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),yi=BigInt(1),On=BigInt(2),Ws=(n,e)=>(n+e/On)/e;function mi(n){const e=Gn,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=n*n*n%e,l=u*u*n%e,d=de(l,t,e)*l%e,S=de(d,t,e)*l%e,g=de(S,On,e)*u%e,y=de(g,s,e)*g%e,f=de(y,o,e)*y%e,h=de(f,a,e)*f%e,m=de(h,c,e)*h%e,b=de(m,a,e)*f%e,p=de(b,t,e)*l%e,E=de(p,i,e)*y%e,w=de(E,r,e)*u%e,_=de(w,On,e);if(!At.eql(At.sqr(_),n))throw new Error("Cannot find square root");return _}const At=vo(Gn,void 0,void 0,{sqrt:mi}),tn=al({a:BigInt(0),b:BigInt(7),Fp:At,n:Cn,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Cn,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-yi*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,i=BigInt("0x100000000000000000000000000000000"),a=Ws(o*n,e),c=Ws(-r*n,e);let u=ce(n-a*t-c*s,e),l=ce(-a*r-c*o,e);const d=u>i,S=l>i;if(d&&(u=e-u),S&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:d,k1:u,k2neg:S,k2:l}}}},Zt),Zn=BigInt(0),bi=n=>typeof n=="bigint"&&Zn<n&&n<Gn,cl=n=>typeof n=="bigint"&&Zn<n&&n<Cn,Vs={};function Un(n,...e){let t=Vs[n];if(t===void 0){const r=Zt(Uint8Array.from(n,s=>s.charCodeAt(0)));t=Ne(r,r),Vs[n]=t}return Zt(Ne(t,...e))}const ps=n=>n.toRawBytes(!0).slice(1),_r=n=>_t(n,32),hr=n=>ce(n,Gn),hn=n=>ce(n,Cn),gs=tn.ProjectivePoint,ul=(n,e,t)=>gs.BASE.multiplyAndAddUnsafe(n,e,t);function Br(n){let e=tn.utils.normPrivateKeyToScalar(n),t=gs.fromPrivateKey(e);return{scalar:t.hasEvenY()?e:hn(-e),bytes:ps(t)}}function wi(n){if(!bi(n))throw new Error("bad x: need 0 < x < p");const e=hr(n*n),t=hr(e*n+BigInt(7));let r=mi(t);r%On!==Zn&&(r=hr(-r));const s=new gs(n,r,yi);return s.assertValidity(),s}function xi(...n){return hn(He(Un("BIP0340/challenge",...n)))}function ll(n){return Br(n).bytes}function fl(n,e,t=Hn(32)){const r=ue("message",n),{bytes:s,scalar:o}=Br(e),i=ue("auxRand",t,32),a=_r(o^He(Un("BIP0340/aux",i))),c=Un("BIP0340/nonce",a,s,r),u=hn(He(c));if(u===Zn)throw new Error("sign failed: k is zero");const{bytes:l,scalar:d}=Br(u),S=xi(l,s,r),g=new Uint8Array(64);if(g.set(l,0),g.set(_r(hn(d+S*o)),32),!Si(g,r,s))throw new Error("sign: Invalid signature produced");return g}function Si(n,e,t){const r=ue("signature",n,64),s=ue("message",e),o=ue("publicKey",t,32);try{const i=wi(He(o)),a=He(r.subarray(0,32));if(!bi(a))return!1;const c=He(r.subarray(32,64));if(!cl(c))return!1;const u=xi(_r(a),ps(i),s),l=ul(i,c,hn(-u));return!(!l||!l.hasEvenY()||l.toAffine().x!==a)}catch{return!1}}tn.utils.randomPrivateKey;const dl=Cc(At,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(n=>n.map(e=>BigInt(e)))),hl=ol(At,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:At.create(BigInt("-11"))});_o(tn.ProjectivePoint,n=>{const{x:e,y:t}=hl(At.create(n[0]));return dl(e,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:At.ORDER,m:1,k:128,expand:"xmd",hash:Zt});Se.utils.randomPrivateKey;function Gs(n){try{return Se.ExtendedPoint.fromHex(n),!0}catch{return!1}}const pl=(n,e)=>Se.sign(n,e.slice(0,32)),gl=Se.verify,Xt=n=>Z.Buffer.isBuffer(n)?n:n instanceof Uint8Array?Z.Buffer.from(n.buffer,n.byteOffset,n.byteLength):Z.Buffer.from(n);class yl{constructor(e){Object.assign(this,e)}encode(){return Z.Buffer.from(Po(_n,this))}static decode(e){return No(_n,this,e)}static decodeUnchecked(e){return Lo(_n,this,e)}}const _n=new Map;let vi;const ml=32,it=32;function bl(n){return n._bn!==void 0}let Zs=1;vi=Symbol.toStringTag;class M extends yl{constructor(e){if(super({}),this._bn=void 0,bl(e))this._bn=e._bn;else{if(typeof e=="string"){const t=me.decode(e);if(t.length!=it)throw new Error("Invalid public key input");this._bn=new Rs(t)}else this._bn=new Rs(e);if(this._bn.byteLength()>it)throw new Error("Invalid public key input")}}static unique(){const e=new M(Zs);return Zs+=1,new M(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return me.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(Z.Buffer);if(e.length===it)return e;const t=Z.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[vi](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const s=Z.Buffer.concat([e.toBuffer(),Z.Buffer.from(t),r.toBuffer()]),o=Zt(s);return new M(o)}static createProgramAddressSync(e,t){let r=Z.Buffer.alloc(0);e.forEach(function(o){if(o.length>ml)throw new TypeError("Max seed length exceeded");r=Z.Buffer.concat([r,Xt(o)])}),r=Z.Buffer.concat([r,t.toBuffer(),Z.Buffer.from("ProgramDerivedAddress")]);const s=Zt(r);if(Gs(s))throw new Error("Invalid seeds, address must fall off the curve");return new M(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,s;for(;r!=0;){try{const o=e.concat(Z.Buffer.from([r]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new M(e);return Gs(t.toBytes())}}M.default=new M("11111111111111111111111111111111");_n.set(M,{kind:"struct",fields:[["_bn","u256"]]});new M("BPFLoader1111111111111111111111111111111111");const Vt=1280-40-8,Ei=127,kr=64;class _i extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(_i.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Bi extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Bi.prototype,"name",{value:"TransactionExpiredTimeoutError"});class cn extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(cn.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Pn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const te=(n="publicKey")=>ye(32,n),Wt=(n="string")=>{const e=D([z("length"),z("lengthPadding"),ye(Nt(z(),-8),"chars")],n),t=e.decode.bind(e),r=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:Z.Buffer.from(o,"utf8")};return r(c,i,a)},s.alloc=o=>z().span+z().span+Z.Buffer.from(o,"utf8").length,s},wl=(n="authorized")=>D([te("staker"),te("withdrawer")],n),xl=(n="lockup")=>D([Ke("unixTimestamp"),Ke("epoch"),te("custodian")],n),Sl=(n="voteInit")=>D([te("nodePubkey"),te("authorizedVoter"),te("authorizedWithdrawer"),ae("commission")],n),vl=(n="voteAuthorizeWithSeedArgs")=>D([z("voteAuthorizationType"),te("currentAuthorityDerivedKeyOwnerPubkey"),Wt("currentAuthorityDerivedKeySeed"),te("newAuthorized")],n);function Ge(n){let e=0,t=0;for(;;){let r=n.shift();if(e|=(r&127)<<t*7,t+=1,(r&128)===0)break}return e}function Ze(n,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){n.push(r);break}else r|=128,n.push(r)}}function we(n,e){if(!n)throw new Error(e||"Assertion failed")}class Yn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,s=i=>{const a=i.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Yn(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];we(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{we(t.length>0,"Expected at least one writable signer key");const[c]=t[0];we(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new M(c)),...r.map(([c])=>new M(c)),...s.map(([c])=>new M(c)),...o.map(([c])=>new M(c))];return[i,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new M(o),c=e.findIndex(u=>u.equals(a));c>=0&&(we(c<256,"Max lookup table index exceeded"),r.push(c),s.push(a),this.keyMetaMap.delete(o))}return[r,s]}}class It{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new M(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:me.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Pn(this.staticAccountKeys)}static compile(e){const t=Yn.compile(e.instructions,e.payerKey),[r,s]=t.getMessageComponents(),i=new Pn(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:me.encode(a.data)}));return new It({header:r,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ze(t,e);const r=this.instructions.map(d=>{const{accounts:S,programIdIndex:g}=d,y=Array.from(me.decode(d.data));let f=[];Ze(f,S.length);let h=[];return Ze(h,y.length),{programIdIndex:g,keyIndicesCount:Z.Buffer.from(f),keyIndices:S,dataLength:Z.Buffer.from(h),data:y}});let s=[];Ze(s,r.length);let o=Z.Buffer.alloc(Vt);Z.Buffer.from(s).copy(o);let i=s.length;r.forEach(d=>{i+=D([ae("programIdIndex"),ye(d.keyIndicesCount.length,"keyIndicesCount"),De(ae("keyIndex"),d.keyIndices.length,"keyIndices"),ye(d.dataLength.length,"dataLength"),De(ae("userdatum"),d.data.length,"data")]).encode(d,o,i)}),o=o.slice(0,i);const a=D([ye(1,"numRequiredSignatures"),ye(1,"numReadonlySignedAccounts"),ye(1,"numReadonlyUnsignedAccounts"),ye(t.length,"keyCount"),De(te("key"),e,"keys"),te("recentBlockhash")]),c={numRequiredSignatures:Z.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:Z.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:Z.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:Z.Buffer.from(t),keys:this.accountKeys.map(d=>Xt(d.toBytes())),recentBlockhash:me.decode(this.recentBlockhash)};let u=Z.Buffer.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&Ei))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),o=t.shift(),i=Ge(t);let a=[];for(let S=0;S<i;S++){const g=t.slice(0,it);t=t.slice(it),a.push(new M(Z.Buffer.from(g)))}const c=t.slice(0,it);t=t.slice(it);const u=Ge(t);let l=[];for(let S=0;S<u;S++){const g=t.shift(),y=Ge(t),f=t.slice(0,y);t=t.slice(y);const h=Ge(t),m=t.slice(0,h),b=me.encode(Z.Buffer.from(m));t=t.slice(h),l.push({programIdIndex:g,accounts:f,data:b})}const d={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:me.encode(Z.Buffer.from(c)),accountKeys:a,instructions:l};return new It(d)}}class Nn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Pn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const s=e-r,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=e.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=Yn.compile(e.instructions,e.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const d=t.extractTableLookup(l);if(d!==void 0){const[S,{writable:g,readonly:y}]=d;r.push(S),s.writable.push(...g),s.readonly.push(...y)}}const[i,a]=t.getMessageComponents(),u=new Pn(a,s).compileInstructions(e.instructions);return new Nn({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:u,addressTableLookups:r})}serialize(){const e=Array();Ze(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();Ze(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Ze(o,this.addressTableLookups.length);const i=D([ae("prefix"),D([ae("numRequiredSignatures"),ae("numReadonlySignedAccounts"),ae("numReadonlyUnsignedAccounts")],"header"),ye(e.length,"staticAccountKeysLength"),De(te(),this.staticAccountKeys.length,"staticAccountKeys"),te("recentBlockhash"),ye(r.length,"instructionsLength"),ye(t.length,"serializedInstructions"),ye(o.length,"addressTableLookupsLength"),ye(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Vt),c=1<<7,u=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:me.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,u)}serializeInstructions(){let e=0;const t=new Uint8Array(Vt);for(const r of this.compiledInstructions){const s=Array();Ze(s,r.accountKeyIndexes.length);const o=Array();Ze(o,r.data.length),e+=D([ae("programIdIndex"),ye(s.length,"encodedAccountKeyIndexesLength"),De(ae(),r.accountKeyIndexes.length,"accountKeyIndexes"),ye(o.length,"encodedDataLength"),ye(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Vt);for(const r of this.addressTableLookups){const s=Array();Ze(s,r.writableIndexes.length);const o=Array();Ze(o,r.readonlyIndexes.length),e+=D([te("accountKey"),ye(s.length,"encodedWritableIndexesLength"),De(ae(),r.writableIndexes.length,"writableIndexes"),ye(o.length,"encodedReadonlyIndexesLength"),De(ae(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),s=r&Ei;we(r!==s,"Expected versioned message but received legacy message");const o=s;we(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=Ge(t);for(let y=0;y<c;y++)a.push(new M(t.splice(0,it)));const u=me.encode(t.splice(0,it)),l=Ge(t),d=[];for(let y=0;y<l;y++){const f=t.shift(),h=Ge(t),m=t.splice(0,h),b=Ge(t),p=new Uint8Array(t.splice(0,b));d.push({programIdIndex:f,accountKeyIndexes:m,data:p})}const S=Ge(t),g=[];for(let y=0;y<S;y++){const f=new M(t.splice(0,it)),h=Ge(t),m=t.splice(0,h),b=Ge(t),p=t.splice(0,b);g.push({accountKey:f,writableIndexes:m,readonlyIndexes:p})}return new Nn({header:i,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:d,addressTableLookups:g})}}let rt;(function(n){n[n.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",n[n.PROCESSED=1]="PROCESSED",n[n.TIMED_OUT=2]="TIMED_OUT",n[n.NONCE_INVALID=3]="NONCE_INVALID"})(rt||(rt={}));const El=Z.Buffer.alloc(kr).fill(0);class Ys{constructor(e){this.keys=void 0,this.programId=void 0,this.data=Z.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class st{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Ys(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let f=0;f<t.length;f++)if(t[f].programId===void 0)throw new Error(`Transaction instruction index ${f} has undefined program id`);const s=[],o=[];t.forEach(f=>{f.keys.forEach(m=>{o.push({...m})});const h=f.programId.toString();s.includes(h)||s.push(h)}),s.forEach(f=>{o.push({pubkey:new M(f),isSigner:!1,isWritable:!1})});const i=[];o.forEach(f=>{const h=f.pubkey.toString(),m=i.findIndex(b=>b.pubkey.toString()===h);m>-1?(i[m].isWritable=i[m].isWritable||f.isWritable,i[m].isSigner=i[m].isSigner||f.isSigner):i.push(f)}),i.sort(function(f,h){return f.isSigner!==h.isSigner?f.isSigner?-1:1:f.isWritable!==h.isWritable?f.isWritable?-1:1:f.pubkey.toBase58().localeCompare(h.pubkey.toBase58())});const a=i.findIndex(f=>f.pubkey.equals(r));if(a>-1){const[f]=i.splice(a,1);f.isSigner=!0,f.isWritable=!0,i.unshift(f)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const f of this.signatures){const h=i.findIndex(m=>m.pubkey.equals(f.publicKey));if(h>-1)i[h].isSigner||(i[h].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${f.publicKey.toString()}`)}let c=0,u=0,l=0;const d=[],S=[];i.forEach(({pubkey:f,isSigner:h,isWritable:m})=>{h?(d.push(f.toString()),c+=1,m||(u+=1)):(S.push(f.toString()),m||(l+=1))});const g=d.concat(S),y=t.map(f=>{const{data:h,programId:m}=f;return{programIdIndex:g.indexOf(m.toString()),accounts:f.keys.map(b=>g.indexOf(b.pubkey.toString())),data:me.encode(h)}});return y.forEach(f=>{we(f.programIdIndex>=0),f.accounts.forEach(h=>we(h>=0))}),new It({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:g,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const s=r.toString();return t.has(s)?!1:(t.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(s=>{const o=pl(r,s.secretKey);this._addSignature(s.publicKey,Xt(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){we(t.length===64);const r=this.signatures.findIndex(s=>e.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=Z.Buffer.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:r,publicKey:s}of this.signatures)if(r===null){if(t)return!1}else if(!gl(r,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(r&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,r=[];Ze(r,t.length);const s=r.length+t.length*64+e.length,o=Z.Buffer.alloc(s);return we(t.length<256),Z.Buffer.from(r).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(we(i.length===64,"signature has invalid length"),Z.Buffer.from(i).copy(o,r.length+a*64))}),e.copy(o,r.length+t.length*64),we(o.length<=Vt,`Transaction too large: ${o.length} > ${Vt}`),o}get keys(){return we(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return we(this.instructions.length===1),this.instructions[0].programId}get data(){return we(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=Ge(t);let s=[];for(let o=0;o<r;o++){const i=t.slice(0,kr);t=t.slice(kr),s.push(me.encode(Z.Buffer.from(i)))}return st.populate(It.from(t),s)}static populate(e,t=[]){const r=new st;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==me.encode(El)?null:me.decode(s),publicKey:e.accountKeys[o]};r.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});r.instructions.push(new Ys({keys:o,programId:e.accountKeys[s.programIdIndex],data:me.decode(s.data)}))}),r._message=e,r._json=r.toJSON(),r}}new M("SysvarC1ock11111111111111111111111111111111");new M("SysvarEpochSchedu1e111111111111111111111111");new M("Sysvar1nstructions1111111111111111111111111");new M("SysvarRecentB1ockHashes11111111111111111111");new M("SysvarRent111111111111111111111111111111111");new M("SysvarRewards111111111111111111111111111111");new M("SysvarS1otHashes111111111111111111111111111");new M("SysvarS1otHistory11111111111111111111111111");new M("SysvarStakeHistory1111111111111111111111111");function jt(n){return new Promise(e=>setTimeout(e,n))}const _l=Ae("lamportsPerSignature"),ki=D([z("version"),z("state"),te("authorizedPubkey"),te("nonce"),D([_l],"feeCalculator")]);ki.span;class ys{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=ki.decode(Xt(e),0);return new ys({authorizedPubkey:new M(t.authorizedPubkey),nonce:new M(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const Bl=n=>{const e=n.decode.bind(n),t=n.encode.bind(n);return{decode:e,encode:t}},kl=n=>e=>{const t=ye(n,e),{encode:r,decode:s}=Bl(t),o=t;return o.decode=(i,a)=>{const c=s(i,a);return Su(Z.Buffer.from(c))},o.encode=(i,a,c)=>{const u=_u(i,n);return r(u,a,c)},o},Jt=kl(8);Object.freeze({Create:{index:0,layout:D([z("instruction"),Ke("lamports"),Ke("space"),te("programId")])},Assign:{index:1,layout:D([z("instruction"),te("programId")])},Transfer:{index:2,layout:D([z("instruction"),Jt("lamports")])},CreateWithSeed:{index:3,layout:D([z("instruction"),te("base"),Wt("seed"),Ke("lamports"),Ke("space"),te("programId")])},AdvanceNonceAccount:{index:4,layout:D([z("instruction")])},WithdrawNonceAccount:{index:5,layout:D([z("instruction"),Ke("lamports")])},InitializeNonceAccount:{index:6,layout:D([z("instruction"),te("authorized")])},AuthorizeNonceAccount:{index:7,layout:D([z("instruction"),te("authorized")])},Allocate:{index:8,layout:D([z("instruction"),Ke("space")])},AllocateWithSeed:{index:9,layout:D([z("instruction"),te("base"),Wt("seed"),Ke("space"),te("programId")])},AssignWithSeed:{index:10,layout:D([z("instruction"),te("base"),Wt("seed"),te("programId")])},TransferWithSeed:{index:11,layout:D([z("instruction"),Jt("lamports"),Wt("seed"),te("programId")])},UpgradeNonceAccount:{index:12,layout:D([z("instruction")])}});new M("11111111111111111111111111111111");new M("BPFLoader2111111111111111111111111111111111");var Al=Object.prototype.toString,Il=Object.keys||function(n){var e=[];for(var t in n)e.push(t);return e};function un(n,e){var t,r,s,o,i,a,c;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return un(n.toJSON(),e);if(c=Al.call(n),c==="[object Array]"){for(s="[",r=n.length-1,t=0;t<r;t++)s+=un(n[t],!0)+",";return r>-1&&(s+=un(n[t],!0)),s+"]"}else if(c==="[object Object]"){for(o=Il(n).sort(),r=o.length,s="",t=0;t<r;)i=o[t],a=un(n[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(n);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}var Rl=function(n){var e=un(n,!1);if(e!==void 0)return""+e},Xs=Rl;const an=32;function pr(n){let e=0;for(;n>1;)n/=2,e++;return e}function Ll(n){return n===0?1:(n--,n|=n>>1,n|=n>>2,n|=n>>4,n|=n>>8,n|=n>>16,n|=n>>32,n+1)}class Tl{constructor(e,t,r,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=pr(Ll(e+an+1))-pr(an)-1,r=this.getSlotsInEpoch(t),s=e-(r-an);return[t,s]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+r,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*an:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+pr(an)):this.slotsPerEpoch}}class Js extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class H extends Error{constructor({code:e,message:t,data:r},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var Cl=globalThis.fetch;class Ol extends Mu{constructor(e,t,r){const s=o=>{const i=Ku(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,r),this.underlyingSocket=void 0}call(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}const Ul=160,Pl=64,Nl=Ul/Pl,ql=1e3/Nl;function Dl(n,e){let t;try{t=n.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==n.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${n.index}`);return t}const Qs=56;class eo{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Dl(Hl,e),r=e.length-Qs;we(r>=0,"lookup table is invalid"),we(r%32===0,"lookup table is invalid");const s=r/32,{addresses:o}=D([De(te(),s,"addresses")]).decode(e.slice(Qs));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new M(t.authority[0]):void 0,addresses:o.map(i=>new M(i))}}}const Hl={index:1,layout:D([z("typeIndex"),Jt("deactivationSlot"),Ae("lastExtendedSlot"),ae("lastExtendedStartIndex"),ae(),De(te(),Nt(ae(),-1),"authority")])},$l=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function zl(n){const e=n.match($l);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${n}\``);const[t,r,s,o]=e,i=n.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${r}${c}${o}`}const Ee=wn(fs(M),L(),n=>new M(n)),Ai=ds([L(),he("base64")]),ms=wn(fs(Z.Buffer),Ai,n=>Z.Buffer.from(n[0],"base64")),Ml=30*1e3;function Kl(n){if(/^https?:/.test(n)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return n}function fe(n){let e,t;if(typeof n=="string")e=n;else if(n){const{commitment:r,...s}=n;e=r,t=s}return{commitment:e,config:t}}function Ii(n){return ze([I({jsonrpc:he("2.0"),id:L(),result:n}),I({jsonrpc:he("2.0"),id:L(),error:I({code:bn(),message:L(),data:j(Cu())})})])}const Fl=Ii(bn());function X(n){return wn(Ii(n),Fl,e=>"error"in e?e:{...e,result:C(e.result,n)})}function xe(n){return X(I({context:I({slot:x()}),value:n}))}function Xn(n){return I({context:I({slot:x()}),value:n})}function gr(n,e){return n===0?new Nn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new M(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:me.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new It(e)}const jl=I({foundation:x(),foundationTerm:x(),initial:x(),taper:x(),terminal:x()}),Wl=X(O(U(I({epoch:x(),effectiveSlot:x(),amount:x(),postBalance:x(),commission:j(U(x()))})))),Vl=O(I({slot:x(),prioritizationFee:x()})),Gl=I({total:x(),validator:x(),foundation:x(),epoch:x()}),Zl=I({epoch:x(),slotIndex:x(),slotsInEpoch:x(),absoluteSlot:x(),blockHeight:j(x()),transactionCount:j(x())}),Yl=I({slotsPerEpoch:x(),leaderScheduleSlotOffset:x(),warmup:pt(),firstNormalEpoch:x(),firstNormalSlot:x()}),Xl=ti(L(),O(x())),zt=U(ze([I({}),L()])),Jl=I({err:zt}),Ql=he("receivedSignature"),ef=I({"solana-core":L(),"feature-set":j(x())}),to=xe(I({err:U(ze([I({}),L()])),logs:U(O(L())),accounts:j(U(O(U(I({executable:pt(),owner:L(),lamports:x(),data:O(L()),rentEpoch:j(x())}))))),unitsConsumed:j(x()),returnData:j(U(I({programId:L(),data:ds([L(),he("base64")])})))})),tf=xe(I({byIdentity:ti(L(),O(x())),range:I({firstSlot:x(),lastSlot:x()})}));function nf(n,e,t,r,s,o){const i=t||Cl;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(l,d)=>{const S=await new Promise((g,y)=>{try{r(l,d,(f,h)=>g([f,h]))}catch(f){y(f)}});return await i(...S)}),new Hu(async(l,d)=>{const S={method:"POST",body:l,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},rd)};try{let g=5,y,f=500;for(;c?y=await c(n,S):y=await i(n,S),!(y.status!==429||s===!0||(g-=1,g===0));)console.log(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${f}ms delay...`),await jt(f),f*=2;const h=await y.text();y.ok?d(null,h):d(new Error(`${y.status} ${y.statusText}: ${h}`))}catch(g){g instanceof Error&&d(g)}},{})}function rf(n){return(e,t)=>new Promise((r,s)=>{n.request(e,t,(o,i)=>{if(o){s(o);return}r(i)})})}function sf(n){return e=>new Promise((t,r)=>{e.length===0&&t([]);const s=e.map(o=>n.request(o.methodName,o.args));n.request(s,(o,i)=>{if(o){r(o);return}t(i)})})}const of=X(jl),af=X(Gl),cf=X(Vl),uf=X(Zl),lf=X(Yl),ff=X(Xl),df=X(x()),hf=xe(I({total:x(),circulating:x(),nonCirculating:x(),nonCirculatingAccounts:O(Ee)})),Ar=I({amount:L(),uiAmount:U(x()),decimals:x(),uiAmountString:j(L())}),pf=xe(O(I({address:Ee,amount:L(),uiAmount:U(x()),decimals:x(),uiAmountString:j(L())}))),gf=xe(O(I({pubkey:Ee,account:I({executable:pt(),owner:Ee,lamports:x(),data:ms,rentEpoch:x()})}))),Ir=I({program:L(),parsed:bn(),space:x()}),yf=xe(O(I({pubkey:Ee,account:I({executable:pt(),owner:Ee,lamports:x(),data:Ir,rentEpoch:x()})}))),mf=xe(O(I({lamports:x(),address:Ee}))),pn=I({executable:pt(),owner:Ee,lamports:x(),data:ms,rentEpoch:x()}),bf=I({pubkey:Ee,account:pn}),wf=wn(ze([fs(Z.Buffer),Ir]),ze([Ai,Ir]),n=>Array.isArray(n)?C(n,ms):n),Rr=I({executable:pt(),owner:Ee,lamports:x(),data:wf,rentEpoch:x()}),xf=I({pubkey:Ee,account:Rr}),Sf=I({state:ze([he("active"),he("inactive"),he("activating"),he("deactivating")]),active:x(),inactive:x()}),vf=X(O(I({signature:L(),slot:x(),err:zt,memo:U(L()),blockTime:j(U(x()))}))),Ef=X(O(I({signature:L(),slot:x(),err:zt,memo:U(L()),blockTime:j(U(x()))}))),_f=I({subscription:x(),result:Xn(pn)}),Bf=I({pubkey:Ee,account:pn}),kf=I({subscription:x(),result:Xn(Bf)}),Af=I({parent:x(),slot:x(),root:x()}),If=I({subscription:x(),result:Af}),Rf=ze([I({type:ze([he("firstShredReceived"),he("completed"),he("optimisticConfirmation"),he("root")]),slot:x(),timestamp:x()}),I({type:he("createdBank"),parent:x(),slot:x(),timestamp:x()}),I({type:he("frozen"),slot:x(),timestamp:x(),stats:I({numTransactionEntries:x(),numSuccessfulTransactions:x(),numFailedTransactions:x(),maxTransactionsPerEntry:x()})}),I({type:he("dead"),slot:x(),timestamp:x(),err:L()})]),Lf=I({subscription:x(),result:Rf}),Tf=I({subscription:x(),result:Xn(ze([Jl,Ql]))}),Cf=I({subscription:x(),result:x()}),Of=I({pubkey:L(),gossip:U(L()),tpu:U(L()),rpc:U(L()),version:U(L())}),no=I({votePubkey:L(),nodePubkey:L(),activatedStake:x(),epochVoteAccount:pt(),epochCredits:O(ds([x(),x(),x()])),commission:x(),lastVote:x(),rootSlot:U(x())}),Uf=X(I({current:O(no),delinquent:O(no)})),Pf=ze([he("processed"),he("confirmed"),he("finalized")]),Nf=I({slot:x(),confirmations:U(x()),err:zt,confirmationStatus:j(Pf)}),qf=xe(O(U(Nf))),Df=X(x()),Ri=I({accountKey:Ee,writableIndexes:O(x()),readonlyIndexes:O(x())}),bs=I({signatures:O(L()),message:I({accountKeys:O(L()),header:I({numRequiredSignatures:x(),numReadonlySignedAccounts:x(),numReadonlyUnsignedAccounts:x()}),instructions:O(I({accounts:O(x()),data:L(),programIdIndex:x()})),recentBlockhash:L(),addressTableLookups:j(O(Ri))})}),Li=I({pubkey:Ee,signer:pt(),writable:pt(),source:j(ze([he("transaction"),he("lookupTable")]))}),Ti=I({accountKeys:O(Li),signatures:O(L())}),Ci=I({parsed:bn(),program:L(),programId:Ee}),Oi=I({accounts:O(Ee),data:L(),programId:Ee}),Hf=ze([Oi,Ci]),$f=ze([I({parsed:bn(),program:L(),programId:L()}),I({accounts:O(L()),data:L(),programId:L()})]),Ui=wn(Hf,$f,n=>"accounts"in n?C(n,Oi):C(n,Ci)),Pi=I({signatures:O(L()),message:I({accountKeys:O(Li),instructions:O(Ui),recentBlockhash:L(),addressTableLookups:j(U(O(Ri)))})}),qn=I({accountIndex:x(),mint:L(),owner:j(L()),uiTokenAmount:Ar}),Ni=I({writable:O(Ee),readonly:O(Ee)}),Jn=I({err:zt,fee:x(),innerInstructions:j(U(O(I({index:x(),instructions:O(I({accounts:O(x()),data:L(),programIdIndex:x()}))})))),preBalances:O(x()),postBalances:O(x()),logMessages:j(U(O(L()))),preTokenBalances:j(U(O(qn))),postTokenBalances:j(U(O(qn))),loadedAddresses:j(Ni),computeUnitsConsumed:j(x())}),ws=I({err:zt,fee:x(),innerInstructions:j(U(O(I({index:x(),instructions:O(Ui)})))),preBalances:O(x()),postBalances:O(x()),logMessages:j(U(O(L()))),preTokenBalances:j(U(O(qn))),postTokenBalances:j(U(O(qn))),loadedAddresses:j(Ni),computeUnitsConsumed:j(x())}),nn=ze([he(0),he("legacy")]),Mt=I({pubkey:L(),lamports:x(),postBalance:U(x()),rewardType:U(L()),commission:j(U(x()))}),zf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),transactions:O(I({transaction:bs,meta:U(Jn),version:j(nn)})),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),Mf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),Kf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),transactions:O(I({transaction:Ti,meta:U(Jn),version:j(nn)})),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),Ff=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),transactions:O(I({transaction:Pi,meta:U(ws),version:j(nn)})),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),jf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),transactions:O(I({transaction:Ti,meta:U(ws),version:j(nn)})),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),Wf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),rewards:j(O(Mt)),blockTime:U(x()),blockHeight:U(x())}))),Vf=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),transactions:O(I({transaction:bs,meta:U(Jn)})),rewards:j(O(Mt)),blockTime:U(x())}))),ro=X(U(I({blockhash:L(),previousBlockhash:L(),parentSlot:x(),signatures:O(L()),blockTime:U(x())}))),yr=X(U(I({slot:x(),meta:Jn,blockTime:j(U(x())),transaction:bs,version:j(nn)}))),En=X(U(I({slot:x(),transaction:Pi,meta:U(ws),blockTime:j(U(x())),version:j(nn)}))),Gf=xe(I({blockhash:L(),feeCalculator:I({lamportsPerSignature:x()})})),Zf=xe(I({blockhash:L(),lastValidBlockHeight:x()})),Yf=I({slot:x(),numTransactions:x(),numSlots:x(),samplePeriodSecs:x()}),Xf=X(O(Yf)),Jf=xe(U(I({feeCalculator:I({lamportsPerSignature:x()})}))),Qf=X(L()),ed=X(L()),td=I({err:zt,logs:O(L()),signature:L()}),nd=I({result:Xn(td),subscription:x()}),rd={"solana-client":"js/0.0.0-development"};class sd{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{var f;const{commitment:d,config:S}=fe(l),g=this._buildArgs([],d,void 0,S),y=Xs(g);return u[y]=(f=u[y])!=null?f:(async()=>{try{const h=await this._rpcRequest("getBlockHeight",g),m=C(h,X(x()));if("error"in m)throw new H(m.error,"failed to get block height information");return m.result}finally{delete u[y]}})(),await u[y]}})();let r,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Kl(e),this._rpcWsEndpoint=r||zl(e),this._rpcClient=nf(e,s,o,i,a,c),this._rpcRequest=rf(this._rpcClient),this._rpcBatchRequest=sf(this._rpcClient),this._rpcWebSocket=new Ol(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,void 0,s),i=await this._rpcRequest("getBalance",o),a=C(i,xe(x()));if("error"in a)throw new H(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=C(t,X(U(x())));if("error"in r)throw new H(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=C(e,X(x()));if("error"in t)throw new H(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=C(e,df);if("error"in t)throw new H(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),s=C(r,hf);if("error"in s)throw new H(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",r),o=C(s,xe(Ar));if("error"in o)throw new H(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",r),o=C(s,xe(Ar));if("error"in o)throw new H(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,r){const{commitment:s,config:o}=fe(r);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=C(c,gf);if("error"in u)throw new H(u.error,`failed to get token accounts owned by account ${e.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(e,t,r){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=C(i,yf);if("error"in a)throw new H(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",r),o=C(s,mf);if("error"in o)throw new H(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",r),o=C(s,pf);if("error"in o)throw new H(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=C(i,xe(U(pn)));if("error"in a)throw new H(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=C(i,xe(U(Rr)));if("error"in a)throw new H(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:s}=fe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],r,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=C(a,xe(O(U(Rr))));if("error"in c)throw new H(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:s}=fe(t),o=e.map(u=>u.toBase58()),i=this._buildArgs([o],r,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=C(a,xe(O(U(pn))));if("error"in c)throw new H(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:s,config:o}=fe(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:r!=null?r:o==null?void 0:o.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=C(a,X(Sf));if("error"in c)throw new H(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:s}=fe(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],r,o||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),u=C(c,X(O(bf)));if("error"in u)throw new H(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=C(i,X(O(xf)));if("error"in a)throw new H(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var o;let r;if(typeof e=="string")r=e;else{const i=e;if((o=i.abortSignal)!=null&&o.aborted)return Promise.reject(i.abortSignal.reason);r=i.signature}let s;try{s=me.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return we(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,s,o=!1;const i=new Promise((c,u)=>{try{r=this.onSignature(t,(d,S)=>{r=void 0;const g={context:S,value:d};c({__type:rt.PROCESSED,response:g})},e);const l=new Promise(d=>{r==null?d():s=this._onSubscriptionStateChange(r,S=>{S==="subscribed"&&d()})});(async()=>{if(await l,o)return;const d=await this.getSignatureStatus(t);if(o||d==null)return;const{context:S,value:g}=d;if(g!=null)if(g!=null&&g.err)u(g.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(g.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(g.confirmationStatus==="processed"||g.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:rt.PROCESSED,response:{context:S,value:g}})}})()}catch(l){u(l)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:s}}){let o=!1;const i=new Promise(d=>{const S=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let g=await S();if(!o){for(;g<=r;)if(await jt(1e3),o||(g=await S(),o))return;d({__type:rt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),u=this.getCancellationPromise(t);let l;try{const d=await Promise.race([u,c,i]);if(d.__type===rt.PROCESSED)l=d.response;else throw new _i(s)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:s,nonceValue:o,signature:i}}){var g;let a=!1;const c=new Promise(y=>{let f=o,h=null;const m=async()=>{try{const{context:b,value:p}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:r});return h=b.slot,p==null?void 0:p.nonce}catch{return f}};(async()=>{if(f=await m(),!a)for(;;){if(o!==f){y({__type:rt.NONCE_INVALID,slotInWhichNonceDidAdvance:h});return}if(await jt(2e3),a||(f=await m(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),d=this.getCancellationPromise(t);let S;try{const y=await Promise.race([d,l,c]);if(y.__type===rt.PROCESSED)S=y.response;else{let f;for(;;){const h=await this.getSignatureStatus(i);if(h==null)break;if(h.context.slot<((g=y.slotInWhichNonceDidAdvance)!=null?g:r)){await jt(400);continue}f=h;break}if(f!=null&&f.value){const h=e||"finalized",{confirmationStatus:m}=f.value;switch(h){case"processed":case"recent":if(m!=="processed"&&m!=="confirmed"&&m!=="finalized")throw new cn(i);break;case"confirmed":case"single":case"singleGossip":if(m!=="confirmed"&&m!=="finalized")throw new cn(i);break;case"finalized":case"max":case"root":if(m!=="finalized")throw new cn(i);break;default:(b=>{})(h)}S={context:f.context,value:{err:f.value.err}}}else throw new cn(i)}}finally{a=!0,u()}return S}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const s=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:rt.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===rt.PROCESSED)a=c.response;else throw new Bi(t,c.timeoutMs/1e3)}finally{clearTimeout(r),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=C(e,X(O(Of)));if("error"in t)throw new H(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),s=C(r,Uf);if("error"in s)throw new H(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlot",s),i=C(o,X(x()));if("error"in i)throw new H(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getSlotLeader",s),i=C(o,X(L()));if("error"in i)throw new H(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],s=await this._rpcRequest("getSlotLeaders",r),o=C(s,X(O(Ee)));if("error"in o)throw new H(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:r,value:s}=await this.getSignatureStatuses([e],t);we(s.length===1);const o=s[0];return{context:r,value:o}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const s=await this._rpcRequest("getSignatureStatuses",r),o=C(s,qf);if("error"in o)throw new H(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getTransactionCount",s),i=C(o,X(x()));if("error"in i)throw new H(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),s=C(r,of);if("error"in s)throw new H(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,r){const{commitment:s,config:o}=fe(r),i=this._buildArgs([e.map(u=>u.toBase58())],s,void 0,{...o,epoch:t!=null?t:o==null?void 0:o.epoch}),a=await this._rpcRequest("getInflationReward",i),c=C(a,Wl);if("error"in c)throw new H(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=C(e,af);if("error"in t)throw new H(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getEpochInfo",s),i=C(o,uf);if("error"in i)throw new H(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=C(e,lf);if("error"in t)throw new H(t.error,"failed to get epoch schedule");const r=t.result;return new Tl(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=C(e,ff);if("error"in t)throw new H(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",r),o=C(s,Df);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),s=C(r,Gf);if("error"in s)throw new H(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=C(t,Xf);if("error"in r)throw new H(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",r),o=C(s,Jf);if("error"in o)throw new H(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=Xt(e.serialize()).toString("base64"),s=this._buildArgs([r],t),o=await this._rpcRequest("getFeeForMessage",s),i=C(o,xe(U(x())));if("error"in i)throw new H(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),r=this._buildArgs(t!=null&&t.length?[t]:[]),s=await this._rpcRequest("getRecentPrioritizationFees",r),o=C(s,cf);if("error"in o)throw new H(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,void 0,r),o=await this._rpcRequest("getLatestBlockhash",s),i=C(o,Zf);if("error"in i)throw new H(i.error,"failed to get latest blockhash");return i.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=C(e,X(ef));if("error"in t)throw new H(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=C(e,X(L()));if("error"in t)throw new H(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=C(i,Kf);if("error"in a)throw a.error;return a.result}case"none":{const a=C(i,Mf);if("error"in a)throw a.error;return a.result}default:{const a=C(i,zf);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:d})=>({meta:l,transaction:{...u,message:gr(d,u.message)},version:d}))}:null}}}catch(a){throw new H(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=C(i,jf);if("error"in a)throw a.error;return a.result}case"none":{const a=C(i,Wf);if("error"in a)throw a.error;return a.result}default:{const a=C(i,Ff);if("error"in a)throw a.error;return a.result}}}catch(a){throw new H(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const s=this._buildArgs([],r,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=C(o,tf);if("error"in i)throw new H(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getTransaction",o),a=C(i,yr);if("error"in a)throw new H(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:gr(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:s}=fe(t),o=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=C(i,En);if("error"in a)throw new H(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:s}=fe(t),o=e.map(c=>{const u=this._buildArgsAtLeastConfirmed([c],r,"jsonParsed",s);return{methodName:"getTransaction",args:u}});return(await this._rpcBatchRequest(o)).map(c=>{const u=C(c,En);if("error"in u)throw new H(u.error,"failed to get transactions");return u.result})}async getTransactions(e,t){const{commitment:r,config:s}=fe(t),o=e.map(c=>{const u=this._buildArgsAtLeastConfirmed([c],r,void 0,s);return{methodName:"getTransaction",args:u}});return(await this._rpcBatchRequest(o)).map(c=>{const u=C(c,yr);if("error"in u)throw new H(u.error,"failed to get transactions");const l=u.result;return l&&{...l,transaction:{...l.transaction,message:gr(l.version,l.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",r),o=C(s,Vf);if("error"in o)throw new H(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:u})=>{const l=new It(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:st.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),o=await this._rpcRequest("getBlocks",s),i=C(o,X(O(x())));if("error"in i)throw new H(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),o=C(s,ro);if("error"in o)throw new H(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",r),o=C(s,ro);if("error"in o)throw new H(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",r),o=C(s,yr);if("error"in o)throw new H(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new It(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:st.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",r),o=C(s,En);if("error"in o)throw new H(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const r=e.map(i=>{const a=this._buildArgsAtLeastConfirmed([i],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:a}});return(await this._rpcBatchRequest(r)).map(i=>{const a=C(i,En);if("error"in a)throw new H(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,r){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(r++,!(r>i));)try{const c=await this.getConfirmedBlockSignatures(r);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=C(o,vf);if("error"in i)throw new H(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=C(o,Ef);if("error"in i)throw new H(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new eo({key:e,state:eo.deserialize(s.data)})),{context:r,value:o}}async getNonceAndContext(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=ys.fromAccountData(s.data)),{context:r,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=C(r,Qf);if("error"in s)throw new H(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await jt(100);const r=Date.now()-this._blockhashInfo.lastFetch>=Ml;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(r!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await jt(ql/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=fe(e),s=this._buildArgs([],t,"base64",r),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=C(o,xe(x()));if("error"in i)throw new H(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const f=e.serialize(),h=Z.Buffer.from(f).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const m=t||{};m.encoding="base64","commitment"in m||(m.commitment=this.commitment);const b=[h,m],p=await this._rpcRequest("simulateTransaction",b),E=C(p,to);if("error"in E)throw new Error("failed to simulate transaction: "+E.error.message);return E.result}let s;if(e instanceof st){let y=e;s=new st,s.feePayer=y.feePayer,s.instructions=e.instructions,s.nonceInfo=y.nonceInfo,s.signatures=y.signatures}else s=st.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){const f=await this._blockhashWithExpiryBlockHeight(y);if(s.lastValidBlockHeight=f.lastValidBlockHeight,s.recentBlockhash=f.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const h=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(h)&&!this._blockhashInfo.transactionSignatures.includes(h)){this._blockhashInfo.simulatedSignatures.push(h);break}else y=!0}}const i=s._compile(),a=i.serialize(),u=s._serialize(a).toString("base64"),l={encoding:"base64",commitment:this.commitment};if(r){const y=(Array.isArray(r)?r:i.nonProgramIds()).map(f=>f.toBase58());l.accounts={encoding:"base64",addresses:y}}o&&(l.sigVerify=!0);const d=[u,l],S=await this._rpcRequest("simulateTransaction",d),g=C(S,to);if("error"in g){let y;if("data"in g.error&&(y=g.error.data.logs,y&&Array.isArray(y))){const f=`
    `,h=f+y.join(f);console.error(g.error.message,h)}throw new Js("failed to simulate transaction: "+g.error.message,y)}return g.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,r)}async sendRawTransaction(e,t){const r=Xt(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},s=t&&t.skipPreflight,o=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),s&&(r.skipPreflight=s),o&&(r.preflightCommitment=o);const i=[e,r],a=await this._rpcRequest("sendTransaction",i),c=C(a,ed);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new Js("failed to send transaction: "+c.error.message,u)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){var s;const r=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const o=this._subscriptionStateChangeCallbacksByHash[e];o&&o.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var o;const r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};const s=(o=this._subscriptionStateChangeCallbacksByHash)[r]||(o[r]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const s=this._subscriptionsByHash[r];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[r],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(r,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(r,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,o,a.message),!t())return;this._setSubscription(r,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(r,{...s,state:"unsubscribing"}),this._setSubscription(r,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(r,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=C(e,_f);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,s=Xs([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const i=this._subscriptionsByHash[s];we(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=C(e,kf);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,s){const o=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=C(e,nd);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=C(e,If);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=C(e,Lf);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,s){const o=t||this._commitment;if(o||r||s){let i={};r&&(i.encoding=r),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,r,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,s)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=C(e,Tf);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const s=this._buildArgs([e],r||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,r){const{commitment:s,...o}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,u)=>{t(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=C(e,Cf);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}Object.freeze({CreateLookupTable:{index:0,layout:D([z("instruction"),Jt("recentSlot"),ae("bumpSeed")])},FreezeLookupTable:{index:1,layout:D([z("instruction")])},ExtendLookupTable:{index:2,layout:D([z("instruction"),Jt(),De(te(),Nt(z(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:D([z("instruction")])},CloseLookupTable:{index:4,layout:D([z("instruction")])}});new M("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:D([ae("instruction"),z("units"),z("additionalFee")])},RequestHeapFrame:{index:1,layout:D([ae("instruction"),z("bytes")])},SetComputeUnitLimit:{index:2,layout:D([ae("instruction"),z("units")])},SetComputeUnitPrice:{index:3,layout:D([ae("instruction"),Jt("microLamports")])}});new M("ComputeBudget111111111111111111111111111111");D([ae("numSignatures"),ae("padding"),Ve("signatureOffset"),Ve("signatureInstructionIndex"),Ve("publicKeyOffset"),Ve("publicKeyInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),Ve("messageInstructionIndex")]);new M("Ed25519SigVerify111111111111111111111111111");tn.utils.isValidPrivateKey;tn.getPublicKey;D([ae("numSignatures"),Ve("signatureOffset"),ae("signatureInstructionIndex"),Ve("ethAddressOffset"),ae("ethAddressInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),ae("messageInstructionIndex"),ye(20,"ethAddress"),ye(64,"signature"),ae("recoveryId")]);new M("KeccakSecp256k11111111111111111111111111111");new M("StakeConfig11111111111111111111111111111111");class so{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}so.default=new so(0,0,M.default);Object.freeze({Initialize:{index:0,layout:D([z("instruction"),wl(),xl()])},Authorize:{index:1,layout:D([z("instruction"),te("newAuthorized"),z("stakeAuthorizationType")])},Delegate:{index:2,layout:D([z("instruction")])},Split:{index:3,layout:D([z("instruction"),Ke("lamports")])},Withdraw:{index:4,layout:D([z("instruction"),Ke("lamports")])},Deactivate:{index:5,layout:D([z("instruction")])},Merge:{index:7,layout:D([z("instruction")])},AuthorizeWithSeed:{index:8,layout:D([z("instruction"),te("newAuthorized"),z("stakeAuthorizationType"),Wt("authoritySeed"),te("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});new M("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:D([z("instruction"),Sl()])},Authorize:{index:1,layout:D([z("instruction"),te("newAuthorized"),z("voteAuthorizationType")])},Withdraw:{index:3,layout:D([z("instruction"),Ke("lamports")])},AuthorizeWithSeed:{index:10,layout:D([z("instruction"),vl()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});new M("Vote111111111111111111111111111111111111111");new M("Va1idator1nfo111111111111111111111111111111");I({name:L(),website:j(L()),details:j(L()),keybaseUsername:j(L())});new M("Vote111111111111111111111111111111111111111");D([te("nodePubkey"),te("authorizedWithdrawer"),ae("commission"),Ae(),De(D([Ae("slot"),z("confirmationCount")]),Nt(z(),-8),"votes"),ae("rootSlotValid"),Ae("rootSlot"),Ae(),De(D([Ae("epoch"),te("authorizedVoter")]),Nt(z(),-8),"authorizedVoters"),D([De(D([te("authorizedPubkey"),Ae("epochOfLastAuthorizedSwitch"),Ae("targetEpoch")]),32,"buf"),Ae("idx"),ae("isEmpty")],"priorVoters"),Ae(),De(D([Ae("epoch"),Ae("credits"),Ae("prevCredits")]),Nt(z(),-8),"epochCredits"),D([Ae("slot"),Ae("timestamp")],"lastTimestamp")]);var xs=Object.defineProperty,od=Object.getOwnPropertyDescriptor,qi=Object.getOwnPropertyNames,id=Object.prototype.hasOwnProperty,ad=(n,e)=>function(){return n&&(e=(0,n[qi(n)[0]])(n=0)),e},cd=(n,e)=>{for(var t in e)xs(n,t,{get:e[t],enumerable:!0})},ud=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of qi(e))!id.call(n,s)&&s!==t&&xs(n,s,{get:()=>e[s],enumerable:!(r=od(e,s))||r.enumerable});return n},ld=n=>ud(xs({},"__esModule",{value:!0}),n),Kt=(n,e,t)=>new Promise((r,s)=>{var o=c=>{try{a(t.next(c))}catch(u){s(u)}},i=c=>{try{a(t.throw(c))}catch(u){s(u)}},a=c=>c.done?r(c.value):Promise.resolve(c.value).then(o,i);a((t=t.apply(n,e)).next())}),Di={};cd(Di,{default:()=>Hi,devDependencies:()=>$r,files:()=>Cr,gitHead:()=>Mr,license:()=>qr,main:()=>Ur,module:()=>Pr,name:()=>Lr,peerDependencies:()=>Hr,publishConfig:()=>Dr,scripts:()=>zr,type:()=>Or,types:()=>Nr,version:()=>Tr});var Lr,Tr,Cr,Or,Ur,Pr,Nr,qr,Dr,Hr,$r,zr,Mr,Hi,fd=ad({"package.json"(){Lr="@particle-network/solana-wallet",Tr="0.13.0",Cr=["es","lib","LICENSE"],Or="module",Ur="lib/index.js",Pr="es/index.js",Nr="lib/types/index.d.ts",qr="Apache-2.0",Dr={access:"public"},Hr={"@particle-network/auth":"^0.12.2","@solana/web3.js":"^1.50.1",bs58:"^4.0.1"},$r={"@particle-network/auth":"^0.13.0","@solana/web3.js":"^1.50.1","@types/bs58":"^4.0.1",bs58:"^4.0.1","ts-loader":"^9.3.1","webpack-cli":"^4.10.0"},zr={clean:"shx rm -rf lib/* && shx rm -rf es/*",package:`shx echo '{ "type": "commonjs" }' > lib/package.json`,build:"yarn clean && node ./esBuild.js && tsc --emitDeclarationOnly -p tsconfig.json && yarn package","build:min.js":"webpack",version:"yarn build"},Mr="2cb4e4fb6c65ed3d861b131a11256414f61c01de",Hi={name:Lr,version:Tr,files:Cr,type:Or,main:Ur,module:Pr,types:Nr,license:qr,publishConfig:Dr,peerDependencies:Hr,devDependencies:$r,scripts:zr,gitHead:Mr}}});function dd(){return`web_${(fd(),ld(Di)).version}`}var yd=class{constructor(n){this.auth=n,this.isParticleNetwork=!0,this.name="Particle",this.url="https://particle.network",this.icon="https://static.particle.network/wallet-icons/Particle.png",this.events=new ra.exports.EventEmitter,this.auth=n,this._connecting=!1;const e=this.auth.userInfo();if(e){const t=e.wallets.find(r=>r.chain_name==="solana"&&r.public_address.length>0);t?this._publicKey=new M(t.public_address):this._publicKey=null}else this._publicKey=null;this.auth.on("connect",t=>{const r=t.wallets.find(s=>s.chain_name==="solana"&&s.public_address.length>0);r&&(this._publicKey=new M(r.public_address),this.events.emit("connect",this._publicKey))}),this.auth.on("disconnect",()=>{this._publicKey=null,this.events.emit("disconnect")}),typeof window!="undefined"&&window.particle&&(window.particle.solanaWallet=this)}get version(){return dd()}on(n,e){this.events.on(n,e)}once(n,e){this.events.once(n,e)}off(n,e){this.events.off(n,e)}removeListener(n,e){this.events.removeListener(n,e)}get connecting(){return this._connecting}get connected(){return this._publicKey!==null}get publicKey(){return this._publicKey}connect(n){return Kt(this,null,function*(){try{this._connecting=!0;let e=this.auth.wallet();return e?(this._publicKey=new M(e.public_address),Promise.resolve()):(yield this.auth.login(n),e=this.auth.wallet(),e?(this._publicKey=new M(e.public_address),Promise.resolve()):Promise.reject("wallet create failed"))}catch(e){return Promise.reject(e)}finally{this._connecting=!1}})}disconnect(){return Kt(this,null,function*(){return yield this.auth.logout(),this._publicKey=null,Promise.resolve()})}signTransaction(n){return Kt(this,null,function*(){const e=yield this.auth.sign("signTransaction",me.encode(n.serialize({requireAllSignatures:!1,verifySignatures:!1})));return st.from(Z.Buffer.from(e,"base64"))})}signAllTransactions(n){return Kt(this,null,function*(){return(yield this.auth.signAllTransactions(n.map(t=>me.encode(t.serialize({requireAllSignatures:!1,verifySignatures:!1}))))).map(t=>st.from(Z.Buffer.from(t,"base64")))})}signAndSendTransaction(n){return Kt(this,null,function*(){return this.auth.sendTransaction(me.encode(n.serialize({requireAllSignatures:!1,verifySignatures:!1})))})}signMessage(n){return Kt(this,null,function*(){const e=yield this.auth.sign("signMessage",me.encode(n));return Z.Buffer.from(e,"base64")})}getConnection(n){const e=sa()?"https://rpc-debug.particle.network/solana":"https://rpc.particle.network/solana";return new sd(`${e}?chainId=${this.auth.chainId()}&projectUuid=${this.auth.config.projectId}&projectKey=${this.auth.config.clientKey}`,{commitment:n==null?void 0:n.commitment,wsEndpoint:n==null?void 0:n.wsEndpoint,httpHeaders:{Authorization:this.auth.basicCredentials()},fetch:n==null?void 0:n.fetch,fetchMiddleware:n==null?void 0:n.fetchMiddleware,disableRetryOnRateLimit:n==null?void 0:n.disableRetryOnRateLimit,confirmTransactionInitialTimeout:n==null?void 0:n.confirmTransactionInitialTimeout})}};export{wd as ParticleNetwork,yd as SolanaWallet};
